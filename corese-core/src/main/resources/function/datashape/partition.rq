#
# SHACL Interpreter 
#
# Olivier Corby - Wimmics Inria I3S - 2016-2020
#

prefix sh:  <http://www.w3.org/ns/shacl#> 
prefix xsh: <http://www.w3.org/ns/shacl#> 
prefix msh: <http://ns.inria.fr/shacl/>


#
# sh: property shape ; qsh: qualified shape ; nodeList: subject path object node list
#
function sh:partitionValueShape (sh, vis, subject, path, qsh, disjoint, amin, amax, nodeList) {
        # list = node list that match qualified shape
        let (list = mapfindlist(sh:qualifiedShape, nodeList,  qsh),
            (partList cardList) = sh:partitionSiblingNodeList(qsh, subject, path, nodeList),
            res = sh:partition(xt:cons(list, partList), xt:cons(xt:list(amin, amax), cardList))) {
            xt:print("shex partition:", res);
            return (res)
        }
}



#
# return list of sibling shape qualified node list
#
function sh:partitionSiblingNodeList(qsh, subject, currentPath, nodeList) {
    let (siblingNodeList = xt:list(), cardList = xt:list(),
        cstList = coalesce(sh:getConstraint(sh:sibling, qsh), xt:list())) {
        for ((sh, path, amin, amax) in cstList) {
            let (target = if (coalesce(currentPath = path, false), nodeList, sh:ppath(subject, path)),
                 targetQualified =  mapfindlist(sh:qualifiedShape, target,  sh)) {
                xt:add(siblingNodeList, targetQualified) ;
                xt:add(cardList, xt:list(amin, amax))
            }
        } ;
        return (xt:list(siblingNodeList, cardList))
    }
}


#
# partList : list of qualified node list
# cardList : list of cardinality min max
# check that there exists a partition of partList that matches cardinality constraints
# remove duplicates from partList except one occcurrence of each duplicate into at most one list
# ((1 2) (2 3)) -> ((1) (2 3)) or ((1 2) (3))
#
function sh:partition(partList, cardList) {
    xt:print("candidate:", partList);
    xt:print("min max:", cardList);
    sh:prepare(partList, cardList);
}

#
# create map: nodeList -> (min, max)
#
function sh:cardinality(partList, cardList) {
    let (amap = xt:map(), i = 0) {
        for (nodeList in partList) {
            xt:set(amap, nodeList, xt:get(cardList, i));
            set (i = i+1)
        } ;
        return (amap)
    }
}

#
# Compute intersection of pairs of set in partList
# Remove intersection from set
# Check size <= max ; i size > max : fail ; if size = max, remove the set
# for elem in intersection(A, B) : put elem -> { A, B } 
# return map elem -> candidate list
# mapInter: nodeList -> list of intersection
# mapCand:  elem -> map of nodeList
# amap: elem -> list of nodeList
# 
function sh:prepare(partList, cardList) {
    let (mapCard  = sh:cardinality(partList, cardList),
         mapInter = sh:intersection(partList), 
         mapCand  = sh:processIntersection(mapInter),
         amap     = sh:mapList(mapCand),
         res      = sh:assign(amap, mapCard)) {
         sh:show (amap);
         return (res)
    }
}

function sh:show(amap) {
    for ((elem list) in amap) {
        xt:print(elem, list)
    }
}

function sh:intersection(partList) {
    # amap: nodeList -> list of intersections with other nodeLists
    let (amap = xt:map()) {
        for (i in xt:iterate(0, xt:size(partList) - 2)) {
            let (l1 = xt:get(partList, i)) {
                for (j in xt:iterate(i+1, xt:size(partList) - 1)) {
                    let (l2 = xt:get(partList, j)) {
                        let (inter = sh:intersection(l1, l2)) {
                            xt:add(sh:getset(amap, l1), inter);
                            xt:add(sh:getset(amap, l2), inter);                            
                        }
                    }
                }
            }
        } ;
        return (amap)
    }
}


# amap: nodeList -> list of intersections with other nodeLists
# return map: elem -> map of nodeList where elem member of intersection
function sh:processIntersection(amap) {
    let (candMap = xt:map()) {
        for ((nodeList interList) in amap) {
            for (inter in interList) {
                for (elem in inter) {
                    xt:remove(nodeList, elem);
                    xt:set(sh:getMap(candMap, elem), nodeList, nodeList)
                }
            }
        } ;
        return (candMap)
    } 
}

# amap:  elem -> map of nodeList
# return elem -> list of nodeList
function sh:mapList(amap) {
    let (res = xt:map()) {
        for ((elem themap) in amap) {
            xt:set(res, elem, maplist(function((key, val)) { val }, themap))
        } ;
        return (res)
    }
}

function sh:getMap(amap, elem) {
    if (! xt:has(amap, elem)) {
        xt:set(amap, elem, xt:map())
    } ;
    return (xt:get(amap, elem))
}

function sh:getset(amap, nodeList) {
    if (! xt:has(amap, nodeList)) {
        xt:set(amap, nodeList, xt:list())
    } ;
    return (xt:get(amap, nodeList))
}

function sh:intersection(l1, l2) {
    let (inter = xt:list()) {
        for (ee in l1) {
            if (xt:member(ee, l2)) {
                xt:add(inter, ee)
            }
        } ;
        return (inter)
    }
}

#
# amap : elem -> list of nodeList
#
function sh:assign(amap, cardList) {
    sh:assign(sh:keys(amap), 0, amap, cardList)
}

function sh:keys(amap) {
    maplist(lambda((elem, list)) { elem }, amap)
}


#
# elemList : list of elem
# i = index of current elem
# map : elem -> set of nodeList
# assign each elem into one of the nodeList ; check size(nodeList) >= min <= max 
#
function sh:assign(elemList, i, amap, cardMap) {
    if (i = xt:size(elemList)) {
        return (sh:checkMin(amap, cardMap) && sh:checkMax(amap, cardMap));
    }
    else {
        let (elem = xt:get(elemList, i)) {
            for (nodeList in xt:get(amap, elem)) {
                if (xt:size(nodeList) < sh:max(nodeList, cardMap)) {
                    xt:add(nodeList, elem);
                    let (res = sh:assign(elemList, i+1, amap, cardMap)) {
                        if (res) {
                            return (true);
                        }
                        else {
                            xt:remove(nodeList, elem)
                        }
                    }
                }
                # else try next nodeList
            } ;
            return (false)
        }
    }
}

function sh:checkMin(amap, cardMap) {
    for ((elem list) in amap) {
        for (nodeList in list) {
            if (xt:size(nodeList) < sh:min(nodeList, cardMap)) {
                return (false)
            }
        }
    } ;
    return (true)
}

function sh:checkMax(amap, cardMap) {
    for ((elem list) in amap) {
        for (nodeList in list) {
            if (xt:size(nodeList) > sh:max(nodeList, cardMap)) {
                return (false)
            }
        }
    } ;
    return (true)
}

function sh:min(nodeList, cardMap) {
    let ((amin amax) = xt:get(cardMap, nodeList)) {
        return (amin)
    }
}

function sh:max(nodeList, cardMap) {
    let ((amin amax) = xt:get(cardMap, nodeList)) {
        return (amax)
    }
}


# check size >= min ; if size < min : fail
function sh:minCardinality(partList, cardList) {
    
}
