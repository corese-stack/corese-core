#
# SHACL Shex Interpreter 
# Implement shex semantics for qualifiedValueShape with a partition of values
#
# Olivier Corby - Wimmics Inria I3S - 2016-2020
#

prefix sh:  <http://www.w3.org/ns/shacl#> 
prefix xsh: <http://www.w3.org/ns/shacl#> 
prefix msh: <http://ns.inria.fr/shacl/>
prefix shex: <http://ns.inria.fr/shex/shacl#>

function sh:dsp(x) {
    if (sh:isdsp(), xt:print(x), true)
}
function sh:dsp(x, y) {
    if (sh:isdsp(), xt:print(x, y), true)
}
function sh:dsp(x, y, z) {
    if (sh:isdsp(), xt:print(x, y, z), true)
}
function sh:isdsp() {
    coalesce(isdsp, false)
}
function sh:setdsp(bb) {
    set(isdsp=bb)
}


#
# sh : sh:property [ sh:path path ; sh:qualifiedValueShape qsh ]
# nodeList : subject path target node list
# cstList : list(qsh)
# shex semantics: 
# consider sibling qualifiedValueShape with same path if any, 
# compute a partition of relevant subset of nodeList that matches cardinality constraint of each sibling qvs
#
function sh:partitionValueShape(sh, vis, subject, path, nodeList, cstList) {
    let (res = true) {
        for ((oper qsh disjoint amin amax extra) in cstList) {
            # there is one qvs in cstList
            let (suc = coalesce(                    
                sh:partitionValueShape(sh, vis, extra, subject, path, qsh, disjoint, amin, amax, nodeList) , 
                false) ) {
                if (! suc, set(res = false), true) 
            }
        };
        return (res)
    }
}


#
# sh: property shape ; qsh: qualified shape ; nodeList: subject path object node list
# extra = true: extra values authorized for subject path  in addition to qualified values
#
function sh:partitionValueShape (sh, vis, extra, subject, path, qsh, disjoint, amin, amax, nodeList) {
        # list = node list that match qualified shape
        sh:dsp("shex partition:");
        sh:dsp(subject, path, nodeList);
        
        let (list               = mapfindlist(sh:qualifiedShape, nodeList,  qsh),
            (partList cardList) = sh:partitionSiblingNodeList(qsh, subject, path, nodeList),
            candidate   = xt:cons(list, partList),
            cardinality = xt:cons(xt:list(amin, amax), cardList)) {
            
            let (res = true) {
                if (! extra) {
                    # check there is no extra node in nodeList that does not match any qvs
                    set (res = ! sh:extra(nodeList, candidate));
                    sh:dsp("extra:", res);
                } ;
                if (res) {
                    if (sh:checkMinCard(candidate, cardinality)) {
                        sh:dsp("check min:", res);
                        if (xt:size(candidate) = 1) {
                            set (res = sh:checkMaxCard(candidate, cardinality));
                            sh:dsp("check max:", res)
                        }
                        else {
                            set (res = sh:partition(candidate, cardinality)) ;
                            sh:dsp("partition:", res)
                        }
                    }
                    else {
                        set (res = false) ;
                        sh:dsp("check min:", res);
                    }
                } ;
                sh:dsp("result:", res);
                sh:report(shex:qualifiedValueShape, sh, subject, path, subject, res, vis) ;
                return (res)
            }
        }
}

# return true if there is  extra node in nodeList wrt candidate
function sh:extra(nodeList, candidate) {
    letdyn (list = candidate) {
        for (node in nodeList) {
            if (mapany (xt:member, node, list), true, return(true))
        }
    } ;
    return (false)
}

#
# return list of sibling shape with same path qualified node list 
#
function sh:partitionSiblingNodeList(qsh, subject, currentPath, nodeList) {
    let (siblingNodeList = xt:list(), cardList = xt:list(),
        cstList = coalesce(sh:getConstraint(sh:sibling, qsh), xt:list())) {
        for ((sh, path, amin, amax) in cstList) {
            if (coalesce(sh:samePath(currentPath, path), false)) {
                let (targetQualified =  mapfindlist(sh:qualifiedShape, nodeList,  sh)) {
                    xt:add(siblingNodeList, targetQualified) ;
                    xt:add(cardList, xt:list(amin, amax))
                }
            }
        } ;
        return (xt:list(siblingNodeList, cardList))
    }
}




#
# partList : list of qualified node list
# cardList : list of cardinality min max
# check that there exists a partition of partList that matches cardinality constraints
# remove duplicates from partList except one occcurrence of each duplicate into at most one list
# ((1 2) (2 3)) -> ((1) (2 3)) or ((1 2) (3))
#
function sh:partition(partList, cardList) {
    sh:dsp("candidate:", partList);
    sh:dsp("min max:", cardList);            
    sh:prepare(partList, cardList);
}


#
# partList: list of qualified nodeList
# cardList:  cardinality constraints for each nodeList 
# check if we can find a partition of partList that matches cardinality constraint
# Compute intersection of pairs of nodeList in partList
# Remove intersection from each nodeList
# TODO: Check size <= max ; i size > max : fail ; if size = max, remove the nodeList
# for elem in intersection(A, B) : put elem -> { A, B } 
# mapInter: nodeList -> list of intersections with other nodeList
# mapCand:  elem -> map of nodeList where elem is member of an intersection of nodeList
# amap: elem -> list of nodeList
# compute a partition with constraint on amap
# 
function sh:prepare(partList, cardList) {
        let (mapCard  = sh:cardinality(partList, cardList),
            mapInter = sh:intersection(partList), 
            mapCand  = sh:processIntersection(mapInter),
            amap     = sh:mapList(mapCand)) {
            
            sh:show(amap);
            sh:show(mapCard);
            
            let (res  = sh:assign(amap, mapCard)) {
                sh:show (amap);
                return (res)
            }
        }
}

function sh:show(amap) {
    for ((elem list) in amap) {
        sh:dsp(elem, list)
    }
}

#
# return amap: nodeList -> list of intersections with other nodeLists
#
function sh:intersection(partList) {
    #sh:dsp("intersection: ", partList);
    let (amap = xt:map()) {
        if (xt:size(partList) = 1) {
            xt:set(amap, xt:get(partList, 0), xt:list(maplist(rq:self, xt:get(partList, 0))))
        }
        else {
            for (i in xt:iterate(0, xt:size(partList) - 2)) {
                let (l1 = xt:get(partList, i)) {
                    for (j in xt:iterate(i+1, xt:size(partList) - 1)) {
                        let (l2 = xt:get(partList, j)) {
                            let (inter = sh:intersection(l1, l2)) {
                                xt:add(sh:getset(amap, l1), inter);
                                xt:add(sh:getset(amap, l2), inter);                            
                            }
                        }
                    }
                }
            } 
        };
        sh:show(amap);
        return (amap)
    }
}


# amap: nodeList -> list of intersections with other nodeLists
# return map: elem -> map of nodeList where elem member of intersection
#
function sh:processIntersection(amap) {
    sh:dsp("process intersection");
    let (candMap = xt:map()) {
        for ((nodeList interList) in amap) {
            for (inter in interList) {
                for (elem in inter) {
                    xt:remove(nodeList, elem);
                    xt:set(sh:getMap(candMap, elem), nodeList, nodeList)
                }
            }
        } ;
        return (candMap)
    } 
}

# amap:  elem -> map of nodeList
# return elem -> list of nodeList
#
function sh:mapList(amap) {
    let (res = xt:map()) {
        for ((elem themap) in amap) {
            xt:set(res, elem, maplist(function((key, val)) { val }, themap))
        } ;
        return (res)
    }
}

#
# amap : elem -> list of nodeList
#
function sh:assign(amap, cardList) {
    sh:assign(sh:keys(amap), 0, amap, cardList)
}

#
# elemList : list of elem
# i = index of current elem
# map : elem -> set of nodeList
# assign each elem into one of the nodeList ; check size(nodeList) >= min <= max 
#
function sh:assign(elemList, i, amap, cardMap) {
    if (i = xt:size(elemList)) {
        return (sh:checkMin(amap, cardMap) && sh:checkMax(amap, cardMap));
    }
    else {
        let (elem = xt:get(elemList, i)) {
            for (nodeList in xt:get(amap, elem)) {
                if (xt:size(nodeList) < sh:max(nodeList, cardMap)) {
                    xt:add(nodeList, elem);
                    let (res = sh:assign(elemList, i+1, amap, cardMap)) {
                        if (res) {
                            return (true);
                        }
                        else {
                            xt:remove(nodeList, elem)
                        }
                    }
                }
                # else try next nodeList
            } ;
            return (false)
        }
    }
}

#
# create map: nodeList -> (min, max)
#
function sh:cardinality(partList, cardList) {
    #sh:dsp("cardinality");
    let (amap = xt:map(), i = 0) {
        for (nodeList in partList) {
            xt:set(amap, nodeList, xt:get(cardList, i));
            set (i = i+1)
        } ;
        #sh:show(amap);
        return (amap)
    }
}


function sh:getMap(amap, elem) {
    if (! xt:has(amap, elem)) {
        xt:set(amap, elem, xt:map())
    } ;
    return (xt:get(amap, elem))
}

function sh:getset(amap, nodeList) {
    if (! xt:has(amap, nodeList)) {
        xt:set(amap, nodeList, xt:list())
    } ;
    return (xt:get(amap, nodeList))
}

function sh:intersection(l1, l2) {
    let (inter = xt:list()) {
        for (ee in l1) {
            if (xt:member(ee, l2)) {
                xt:add(inter, ee)
            }
        } ;
        return (inter)
    }
}



function sh:keys(amap) {
    maplist(lambda((elem, list)) { elem }, amap)
}

function sh:checkMinCard(candidate, cardinality) {
    let (i = 0) {
        for (nodeList in candidate) {
            if (xt:size(nodeList) < xt:get(xt:get(cardinality, i), 0)) {
                return (false)
            }
            else {
                set(i = i+1)
            }
        } ;
        return (true)
    }
}


function sh:checkMaxCard(candidate, cardinality) {
    let (i = 0) {
        for (nodeList in candidate) {
            let (amax = xt:get(xt:get(cardinality, i), 1)) {
                if (amax >= 0 && xt:size(nodeList) > amax) {
                    return (false)
                }
                else {
                    set(i = i+1)
                }
            }
        } ;
        return (true)
    }
}


function sh:checkMin(amap, cardMap) {
    for ((elem list) in amap) {
        for (nodeList in list) {
            if (xt:size(nodeList) < sh:min(nodeList, cardMap)) {
                return (false)
            }
        }
    } ;
    return (true)
}

function sh:checkMax(amap, cardMap) {
    for ((elem list) in amap) {
        for (nodeList in list) {
            if (xt:size(nodeList) > sh:max(nodeList, cardMap)) {
                return (false)
            }
        }
    } ;
    return (true)
}

function sh:min(nodeList, cardMap) {
    let ((amin amax) = xt:get(cardMap, nodeList)) {
        return (amin)
    }
}

function sh:max(nodeList, cardMap) {
    let ((amin amax) = xt:get(cardMap, nodeList)) {
        return (amax)
    }
}


# check size >= min ; if size < min : fail
function sh:minCardinality(partList, cardList) {
    
}
