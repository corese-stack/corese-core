#
# SHACL Interpreter 
#
# Olivier Corby - Wimmics Inria I3S - 2016-2020
#

prefix sh:  <http://www.w3.org/ns/shacl#> 
prefix xsh: <http://www.w3.org/ns/shacl#> 
prefix msh: <http://ns.inria.fr/shacl/>


#
# sh: property shape ; qsh: qualified shape ; nodeList: subject path object node list
#
function sh:partitionValueShape (sh, vis, subject, path, qsh, disjoint, amin, amax, nodeList) {
        # list = node list that match qualified shape
        xt:print("shex partition:");
        xt:print(subject, path, nodeList);
        
        let (list               = mapfindlist(sh:qualifiedShape, nodeList,  qsh),
            (partList cardList) = sh:partitionSiblingNodeList(qsh, subject, path, nodeList),
            candidate   = xt:cons(list, partList),
            cardinality = xt:cons(xt:list(amin, amax), cardList)) {
            
            let (res = if (sh:checkMinCard(candidate, cardinality), 
                    sh:partition(candidate, cardinality), 
                    false)) {
                xt:print("result:", res);
                sh:report(sh:shexQualifiedValueShape, sh, subject, path, subject, res, vis) ;
                return (res)
            }
        }
}



#
# return list of sibling shape with same path qualified node list 
#
function sh:partitionSiblingNodeList(qsh, subject, currentPath, nodeList) {
    let (siblingNodeList = xt:list(), cardList = xt:list(),
        cstList = coalesce(sh:getConstraint(sh:sibling, qsh), xt:list())) {
        for ((sh, path, amin, amax) in cstList) {
            if (coalesce(sh:samePath(currentPath, path), false)) {
                let (targetQualified =  mapfindlist(sh:qualifiedShape, nodeList,  sh)) {
                    xt:add(siblingNodeList, targetQualified) ;
                    xt:add(cardList, xt:list(amin, amax))
                }
            }
        } ;
        return (xt:list(siblingNodeList, cardList))
    }
}




#
# partList : list of qualified node list
# cardList : list of cardinality min max
# check that there exists a partition of partList that matches cardinality constraints
# remove duplicates from partList except one occcurrence of each duplicate into at most one list
# ((1 2) (2 3)) -> ((1) (2 3)) or ((1 2) (3))
#
function sh:partition(partList, cardList) {
    xt:print("candidate:", partList);
    xt:print("min max:", cardList);            
    sh:prepare(partList, cardList);
}


#
# partList: list of qualified nodeList
# cardList:  cardinality constraints for each nodeList 
# check if we can find a partition of partList that matches cardinality constraint
# Compute intersection of pairs of nodeList in partList
# Remove intersection from each nodeList
# TODO: Check size <= max ; i size > max : fail ; if size = max, remove the nodeList
# for elem in intersection(A, B) : put elem -> { A, B } 
# mapInter: nodeList -> list of intersections with other nodeList
# mapCand:  elem -> map of nodeList where elem is member of an intersection of nodeList
# amap: elem -> list of nodeList
# compute a partition with constraint on amap
# 
function sh:prepare(partList, cardList) {
    let (mapCard  = sh:cardinality(partList, cardList),
         mapInter = sh:intersection(partList), 
         mapCand  = sh:processIntersection(mapInter),
         amap     = sh:mapList(mapCand)) {
         
        if (xt:size(partList) = 1) {
            return (sh:checkMin(amap, mapCard) && sh:checkMax(amap, mapCard))
        }
        else {
            let (res  = sh:assign(amap, mapCard)) {
                sh:show (amap);
                return (res)
            }
        }
    }
}

function sh:show(amap) {
    for ((elem list) in amap) {
        xt:print(elem, list)
    }
}

#
# return amap: nodeList -> list of intersections with other nodeLists
#
function sh:intersection(partList) {
    #xt:print("intersection: ", partList);
    let (amap = xt:map()) {
        if (xt:size(partList) = 1) {
            xt:set(amap, xt:get(partList, 0), xt:list(maplist(rq:self, xt:get(partList, 0))))
        }
        else {
            for (i in xt:iterate(0, xt:size(partList) - 2)) {
                let (l1 = xt:get(partList, i)) {
                    for (j in xt:iterate(i+1, xt:size(partList) - 1)) {
                        let (l2 = xt:get(partList, j)) {
                            let (inter = sh:intersection(l1, l2)) {
                                xt:add(sh:getset(amap, l1), inter);
                                xt:add(sh:getset(amap, l2), inter);                            
                            }
                        }
                    }
                }
            } 
        };
        sh:show(amap);
        return (amap)
    }
}


# amap: nodeList -> list of intersections with other nodeLists
# return map: elem -> map of nodeList where elem member of intersection
#
function sh:processIntersection(amap) {
    xt:print("process intersection");
    let (candMap = xt:map()) {
        for ((nodeList interList) in amap) {
            for (inter in interList) {
                for (elem in inter) {
                    xt:remove(nodeList, elem);
                    xt:set(sh:getMap(candMap, elem), nodeList, nodeList)
                }
            }
        } ;
        return (candMap)
    } 
}

# amap:  elem -> map of nodeList
# return elem -> list of nodeList
#
function sh:mapList(amap) {
    let (res = xt:map()) {
        for ((elem themap) in amap) {
            xt:set(res, elem, maplist(function((key, val)) { val }, themap))
        } ;
        return (res)
    }
}

#
# amap : elem -> list of nodeList
#
function sh:assign(amap, cardList) {
    sh:assign(sh:keys(amap), 0, amap, cardList)
}

#
# elemList : list of elem
# i = index of current elem
# map : elem -> set of nodeList
# assign each elem into one of the nodeList ; check size(nodeList) >= min <= max 
#
function sh:assign(elemList, i, amap, cardMap) {
    if (i = xt:size(elemList)) {
        return (sh:checkMin(amap, cardMap) && sh:checkMax(amap, cardMap));
    }
    else {
        let (elem = xt:get(elemList, i)) {
            for (nodeList in xt:get(amap, elem)) {
                if (xt:size(nodeList) < sh:max(nodeList, cardMap)) {
                    xt:add(nodeList, elem);
                    let (res = sh:assign(elemList, i+1, amap, cardMap)) {
                        if (res) {
                            return (true);
                        }
                        else {
                            xt:remove(nodeList, elem)
                        }
                    }
                }
                # else try next nodeList
            } ;
            return (false)
        }
    }
}

#
# create map: nodeList -> (min, max)
#
function sh:cardinality(partList, cardList) {
    #xt:print("cardinality");
    let (amap = xt:map(), i = 0) {
        for (nodeList in partList) {
            xt:set(amap, nodeList, xt:get(cardList, i));
            set (i = i+1)
        } ;
        #sh:show(amap);
        return (amap)
    }
}


function sh:getMap(amap, elem) {
    if (! xt:has(amap, elem)) {
        xt:set(amap, elem, xt:map())
    } ;
    return (xt:get(amap, elem))
}

function sh:getset(amap, nodeList) {
    if (! xt:has(amap, nodeList)) {
        xt:set(amap, nodeList, xt:list())
    } ;
    return (xt:get(amap, nodeList))
}

function sh:intersection(l1, l2) {
    let (inter = xt:list()) {
        for (ee in l1) {
            if (xt:member(ee, l2)) {
                xt:add(inter, ee)
            }
        } ;
        return (inter)
    }
}



function sh:keys(amap) {
    maplist(lambda((elem, list)) { elem }, amap)
}

function sh:checkMinCard(candidate, cardinality) {
    let (i = 0) {
        for (nodeList in candidate) {
            if (xt:size(nodeList) < xt:get(xt:get(cardinality, i), 0)) {
                return (false)
            }
            else {
                set(i = i+1)
            }
        } ;
        return (true)
    }
}



function sh:checkMin(amap, cardMap) {
    for ((elem list) in amap) {
        for (nodeList in list) {
            if (xt:size(nodeList) < sh:min(nodeList, cardMap)) {
                return (false)
            }
        }
    } ;
    return (true)
}

function sh:checkMax(amap, cardMap) {
    for ((elem list) in amap) {
        for (nodeList in list) {
            if (xt:size(nodeList) > sh:max(nodeList, cardMap)) {
                return (false)
            }
        }
    } ;
    return (true)
}

function sh:min(nodeList, cardMap) {
    let ((amin amax) = xt:get(cardMap, nodeList)) {
        return (amin)
    }
}

function sh:max(nodeList, cardMap) {
    let ((amin amax) = xt:get(cardMap, nodeList)) {
        return (amax)
    }
}


# check size >= min ; if size < min : fail
function sh:minCardinality(partList, cardList) {
    
}
