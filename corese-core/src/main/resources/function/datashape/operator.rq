#
# SHACL Interpreter 
#
# Olivier Corby - Wimmics Inria I3S - 2016-2019
#

prefix sh:   <http://www.w3.org/ns/shacl#> 


#
# SPARQL constraint
# focus is the focus node, val is the value of focus to be tested
# for constraint: they are the same, for path: focus=subject ; val=object
# Query MUST return variables: ?this ?path ?value
#
function sh:mysparql(q, sh, cst, shape, focus, val, vis, mes, hasmes) {
    let (maps = xt:sparql(q, "$this", val)) {
      #  if (xt:size(maps) > 0, xt:print("sparql:", maps), true);
        for (m in maps) {
            let ((this path value) = m) {
                if (hasmes) {
                    let (mmes = sh:mymessage(mes, m)) {
                        # xt:print(mmes);
                        # suc = false
                        st:report(sh:sparql, sh, shape, focus, path, value, false, vis)
                    }
                }
                else {
                    # suc = false
                    st:report(sh:sparql, sh, shape, focus, path, value, false, vis)
                }
            }
        } ;
        # results are errors
        return (xt:size(maps) = 0)
    }
}


# replace {?var} by {val} in message
function sh:mymessage(xsd:string mes, dt:mapping m) {
    for ((var val) in m) {
        let (pat = concat('{', var, '}')) {
            if (contains(mes, pat), set(mes = xt:replace(mes, pat, concat('{', val, '}'))), true)
        }
    } ;
    return(mes)
}




function sh:function(shape, node, name) {
    funcall(name, node)
} 


function sh:validURI(url) {
    let (value = xt:validURI(url)) {
       # xt:print(url, value) ;
        return (value)
    }
}

function sh:validURI(shape, url, any) {
    let (value = xt:validURI(url)) {
        return (value)
    }
}

function sh:validURI(shape, sh, subject, path, url) {
    let (value = xt:validURI(url)) {
      #  xt:print("validate URL:", subject, path, url, value) ;
#        xt:print("cst:", xt:focus(shape, xt:turtle(sh)));
        return (value)
    }
}


function sh:count(s, p){
  let (select ?s ?p (count(*) as ?c) where { ?s ?p ?o })
  { return(?c) }
}

function sh:invCount(?o, ?p){
  let (select ?o ?p (count(*) as ?c) where { ?s ?p ?o })
  { return(?c) }
}

function sh:minCount(s, p, m){
    sh:count(s, p) >= m
}

function sh:maxCount(s, p, m){
    sh:count(s, p) <= m
}

function xsd:boolean sh:nodeKind(dt:graph shape, value, dt:uri kind){
    (isURI(value)     && kind IN ( sh:IRI, sh:BlankNodeOrIRI, sh:IRIOrLiteral ) ) ||
    (isLiteral(value) && kind IN ( sh:Literal, sh:BlankNodeOrLiteral, sh:IRIOrLiteral ) ) ||
    (isBlank(value)   && kind IN ( sh:BlankNode, sh:BlankNodeOrIRI, sh:BlankNodeOrLiteral ) )  
}

function xsd:boolean sh:minLength(dt:graph shape, s, m){
    ! isBlank(s) && coalesce(strlen(s) >= m, false) 
}

function xsd:boolean sh:maxLength(shape, s, m){
    ! isBlank(s) && coalesce(strlen(s) <= m, false) 
}

function xsd:boolean sh:minInclusive(shape, o, m){
    o >= m
}

function xsd:boolean sh:minExclusive(shape, o, m){
    o > m
}

function xsd:boolean sh:maxInclusive(shape, o, m){
    o <= m
}

function xsd:boolean sh:maxExclusive(shape, o, m){
    o < m
}

function xsd:boolean sh:datatype(shape, o, dt){
    sh:datatype(o, dt)
}

function xsd:boolean sh:datatype(o, dt){
    if (isLiteral(o), return(datatype(o) = dt && isWellFormed(o)), false)
}

function xsd:boolean sh:minCount(s, m){
    s >= m
}

function xsd:boolean sh:maxCount(s, m){
    s <= m
}

function xsd:boolean sh:hasValue(shape, s, v) {
    s = v
}

function xsd:boolean sh:class(?shape, ?o, ?c){
  exists { ?o rdf:type/rdfs:subClassOf* ?c }
}


function xsd:boolean sh:in(dt:graph ?shape, ?o, ?lv) {
    letdyn (object = o, list = sh:getConstraint(sh:in, shape, lv)) {
        mapany(lambda(value) { 
            object = value && ( ! isLiteral(object) || datatype(object) = datatype(value)) }, 
            list)
    }
}

function sh:in(shape, sh) {
    let (select * (aggregate(?val) as ?list)
         where { graph ?shape { ?sh rdf:rest*/rdf:first ?val } } ) {
         return(list)
    }
}


function xsd:boolean sh:languageIn(dt:graph ?shape, ?o, ?lv){
   if (isLiteral(o)) {
        letdyn (object = o, lan = lang(object), list = sh:getConstraint(sh:in, shape, lv)) {
            return (mapany(lambda(value) { langMatches(lan, value) }, list))
        }
    }
    else {
        return (false)
    }
}


# by default, generate no report for sh:node constraints
# if sh:detail() generate report for sh:node constraints
function xsd:boolean sh:node(dt:graph shape, o, cst){
    sh:core(shape, cst, sh:detail(), o)
}

function xsd:boolean sh:property(dt:graph shape, o, cst){
    sh:core(shape, cst, true, o)
}

function xsd:boolean sh:qualifiedShape(subject, dt:graph shape, qsh){
    sh:core(shape, qsh, false, subject)
}





function xsd:boolean sh:disjoint(dt:list l1, dt:list l2){
    for (x in l1){
            if (xt:member(x, l2)){
                return(false) 
            }     
    } ;
    return(true)
}

function xsd:boolean sh:equal(dt:list l1, dt:list l2){
    return (l1 = l2)
}

