#
# SHACL Interpreter 
#
# Olivier Corby - Wimmics Inria I3S - 2016-2019
#

prefix sh:   <http://www.w3.org/ns/shacl#> 
prefix xsh:  <http://www.w3.org/ns/shacl#> 


#
# Extension
#

#
# constraint function return xsd:boolean 
# called by path and constraint funcall as other operators
#

# sh:trace = sh:eval with trace
function xsh:trace(node, exp) {
    let ((shape) = exp,
         suc = sh:eval(shape, node)) {
        xt:print("trace:", node, xt:turtle(shape), suc) ;
        return (suc)
    }
}

# sh:trace = sh:eval with trace
function xsh:trace(subject, node, exp) {
    let ((shape) = exp,
         suc = sh:eval(shape, node)) {
        xt:print("trace:", subject, node, xt:turtle(shape), suc) ;
        return (suc)
    }
}

# sh:funeval ( [sh:class foaf:Person] )
# shortcut for 
# xsh:function [ sh:eval ([sh:class foaf:Person]) ]
function xsh:funeval(node, exp) {
    let ((shape) = exp,
         suc = sh:eval(shape, node)) {
        return (suc)
    }
}

function sh:success(node, exp) {
    let ((show) = exp) {
        if (coalesce(show, false), xt:print("success:", node), true);
        return (true)
    }
}

function sh:failure(node, exp) {
    let ((show) = exp) {
        if (coalesce(show, false), xt:print("failure:", node), true);
        return (false)
    }
}




#
# path function return list of node 
# called by xsh:function in ppathext
#

# sh:path ( [ sh:exist (rdf:type) ] )
function xsh:exist(subject, node, exp) {
    #xt:print("with path:", exp);
    if (xt:size(exp) > 1, xt:print("sequence must be inside a list: xsh:exist", xt:list(exp)), true);
    let ((path) = exp, 
         list = sh:pathfinder(if (xt:size(exp) > 1, exp, path), node)) {
        if (xt:size(list) > 0, xt:list(node), xt:list())
    }
}

# sh:path ( [ sh:notExist (rdf:type) ] )
function xsh:notExist(subject, node, exp) {
    if (xt:size(exp) > 1, xt:print("sequence must be inside a list: xsh:notExist", xt:list(exp)), true);
    let ((path) = exp, 
         list = sh:pathfinder(if (xt:size(exp) > 1, exp, path), node)) {
        if (xt:size(list) = 0, xt:list(node), xt:list())
    }
}

# sh:path ( [ sh:filter ([shape constraint]) ] )
function xsh:filter(subject, node, exp) {
    #xt:print("with shape:", exp);
    let ((shape) = exp, 
          suc = sh:eval(shape, node)) {
        if (suc, xt:list(node), xt:list())
    }
}


# sh:path ( [ sh:notFilter ([shape constraint]) ] )
function xsh:notFilter(subject, node, exp) {
    let ((shape) = exp, 
          suc = sh:eval(shape, node)) {
        if (suc, xt:list(), xt:list(node))
    }
}


#  [xsh:triple xsh:predicate] [xsh:equal (xsh:subject xsh:object)]
# exp = (xsh:subject xsh:object)
#
function sh:equal(subject, element, exp) {
    let ((fst snd) = exp) {
        if (funcall(fst, element) = funcall(snd, element), xt:list(funcall(fst, element)), xt:list())
    } 
}

function xsh:subject(atriple) {
    xt:subject(atriple)
}
function xsh:predicate(atriple) {
    xt:predicate(atriple)
}
function xsh:object(atriple) {
    xt:object(atriple)
}
function xsh:graph(atriple) {
    xt:graph(atriple)
}

# Expression interpreter

# evaluator for xsh:function [ xsh:compute (rq:gt h:age (rq:mult 2 h:shoesize)) ]
# exp = (rq:gt h:age (rq:mult 2 h:shoesize))
# node = target node
# if property node is missing, coalesce return true
#
function xsh:evaluate(subject, node, exp) {
    coalesce(xsh:compute(node, exp), true)
}

# exp = (rq:gt (h:age (rq:mult (2 h:shoesize))))
# URI : return value of property of node
# (rq:self (URI)) return URI
# (rq:self) return node
# 
function xsh:compute(subject, node, exp) {
    xsh:compute(node, exp)
}


function xsh:compute(node, exp) {
    if (isExtension(exp)) {
        let ((oper param) = exp) {
            if (xt:has(mapfun, oper), 
                funcall(xt:get(mapfun, oper), node, param), 
                xsh:mycompute(node, oper, param))
        } 
    }
    else if (isURI(exp)) {
        xt:value(node, exp)
    }
    else {
        exp
    }
}

function sh:defun(name, value) {
    xt:set(mapfun, name, value)
}

function sh:defun() {
    sh:defun(rq:or, sh:or);
    sh:defun(rq:if, sh:if);
    sh:defun(rq:coalesce, sh:coalesce);
    sh:defun(rq:self, sh:self);
    sh:defun(rq:list, sh:list) ;
    sh:defun(rq:exist, sh:myexist)
}

function xsh:mycompute(node, oper, param) {
     apply(oper, maplist(lambda(ee, node) { xsh:compute(node, ee) }, param, node))
}

# param = (URI)
function sh:myexist(node, param) {
    return (safe(xt:value(node, xt:get(param, 0))))
}

function sh:list(node, param) {
     param
}

function sh:self(node, param) {
     if (xt:size(param) = 0, node, xt:get(param, 0))
}

function sh:coalesce(node, param) {
    if (xt:size(param) = 0) {
        error()
    }
    else {
        let ((exp | rest) = param) {
            coalesce(xsh:compute(node, exp), sh:coalesce(node, rest))
        }
    }
}

function sh:if(node, param) {
    let ((test e1 e2) = param) {
        if (xsh:compute(node, test), sh:compute(node, e1), sh:compute(node, e2))
    }
}

function sh:or(node, param) {
    let ((e1 e2) = param) {
        return(xsh:compute(node, e1) || sh:compute(node, e2))
    }
}


function xsh:function(name, node) {
    funcall(name, node)
} 

function xsh:function(name, node, value) {
    funcall(name, node, value)
} 

function sh:validURI(url) {
    let (value = xt:validURI(url)) {
        return (value)
    }
}

function sh:validURI(shape, url, any) {
    let (value = xt:validURI(url)) {
        return (value)
    }
}

function sh:validURI(shape, sh, subject, path, url) {
    let (value = xt:validURI(url)) {
        return (value)
    }
}



#
# Std 
#

function sh:count(s, p){
  let (select ?s ?p (count(*) as ?c) where { ?s ?p ?o })
  { return(?c) }
}

function sh:invCount(?o, ?p){
  let (select ?o ?p (count(*) as ?c) where { ?s ?p ?o })
  { return(?c) }
}

function sh:minCount(s, p, m){
    sh:count(s, p) >= m
}

function sh:maxCount(s, p, m){
    sh:count(s, p) <= m
}

function xsd:boolean sh:nodeKind(dt:graph shape, value, dt:uri kind){
    (isURI(value)     && kind IN ( sh:IRI, sh:BlankNodeOrIRI, sh:IRIOrLiteral ) ) ||
    (isLiteral(value) && kind IN ( sh:Literal, sh:BlankNodeOrLiteral, sh:IRIOrLiteral ) ) ||
    (isBlank(value)   && kind IN ( sh:BlankNode, sh:BlankNodeOrIRI, sh:BlankNodeOrLiteral ) )  
}

function xsd:boolean sh:minLength(dt:graph shape, s, m){
    ! isBlank(s) && coalesce(strlen(s) >= m, false) 
}

function xsd:boolean sh:maxLength(shape, s, m){
    ! isBlank(s) && coalesce(strlen(s) <= m, false) 
}

function xsd:boolean sh:minInclusive(shape, o, m){
    o >= m
}

function xsd:boolean sh:minExclusive(shape, o, m){
    o > m
}

function xsd:boolean sh:maxInclusive(shape, o, m){
    o <= m
}

function xsd:boolean sh:maxExclusive(shape, o, m){
    o < m
}

function xsd:boolean sh:datatype(shape, o, dt){
    sh:datatype(o, dt)
}

function xsd:boolean sh:datatype(o, dt){
    if (isLiteral(o), return(datatype(o) = dt && isWellFormed(o)), false)
}

function xsd:boolean sh:minCount(s, m){
    s >= m
}

function xsd:boolean sh:maxCount(s, m){
    s <= m
}

function xsd:boolean sh:hasValue(shape, s, v) {
    s = v
}

function xsd:boolean sh:class(?shape, ?o, ?c){
    if (sh:isetup(sh:type), sh:type(?o, ?c), 
        exists { ?o rdf:type/rdfs:subClassOf* ?c })
}

function sh:class(object, class) {
    exists { ?object rdf:type/rdfs:subClassOf* ?class }
}

function sh:type(object, class) {
    exists { ?object rdf:type ?class }
}

function xsd:boolean sh:type(?shape, ?o, ?c){
    exists { ?o rdf:type ?c }
}


function xsd:boolean sh:in(dt:graph ?shape, ?object, ?lv) {
    let (list = sh:getConstraint(sh:in, shape, lv)) {
        for (value in list) { 
            if (object = value && if (isLiteral(object), datatype(object) = datatype(value), true)) {
                return (true)
            } 
        } ;
        return (false)
    }
}

function sh:in(shape, sh) {
    let (select * (aggregate(?val) as ?list)
         where { graph ?shape { ?sh rdf:rest*/rdf:first ?val } } ) {
         return(list)
    }
}


function xsd:boolean sh:languageIn(dt:graph ?shape, ?object, ?lv){
   if (isLiteral(object)) {
        let (lan = lang(object), list = sh:getConstraint(sh:in, shape, lv)) {
            for (value in list) { 
                if (langMatches(lan, value)) {
                    return (true)
                } 
            } ;
            return (false)
        }
    }
    else {
        return (false)
    }
}


# by default, generate no report for sh:node constraints
# if sh:detail() generate report for sh:node constraints
function xsd:boolean sh:node(dt:graph shape, o, cst){
    sh:core(shape, cst, sh:isetup(sh:detail), o)
}

function xsd:boolean sh:property(dt:graph shape, o, cst){
    sh:core(shape, cst, true, o)
}






function xsd:boolean sh:disjoint(dt:list l1, dt:list l2){
    for (x in l1){
            if (xt:member(x, l2)){
                return(false) 
            }     
    } ;
    return(true)
}

function xsd:boolean sh:equal(dt:list l1, dt:list l2){
    return (l1 = l2)
}

