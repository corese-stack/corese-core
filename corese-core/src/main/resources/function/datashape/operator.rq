prefix sh:   <http://www.w3.org/ns/shacl#> 
prefix fun:  <http://www.w3.org/ns/shacl#> 
prefix java: <http://www.w3.org/ns/shacl#> 


function sh:function(shape, node, name) {
    funcall(name, node)
} 


function sh:validURI(url) {
    let (value = xt:validURI(url)) {
        xt:print(url, value) ;
        return (value)
    }
}

function sh:validURI(shape, sh, subject, path, url) {
    let (value = xt:validURI(url)) {
        xt:print("validate URL:", subject, path, url, value) ;
#        xt:print("cst:", xt:focus(shape, xt:turtle(sh)));
        return (value)
    }
}

function sh:count(s, p){
  let (select ?s ?p (count(*) as ?c) where { ?s ?p ?o })
  { return(?c) }
}

function sh:invCount(?o, ?p){
  let (select ?o ?p (count(*) as ?c) where { ?s ?p ?o })
  { return(?c) }
}


function sh:minCount(s, p, m){
    sh:count(s, p) >= m
}

function sh:maxCount(s, p, m){
    sh:count(s, p) <= m
}

function xsd:boolean sh:nodeKind(dt:graph shape, value, dt:uri kind){
    (isURI(value)     && kind IN ( sh:IRI, sh:BlankNodeOrIRI, sh:IRIOrLiteral ) ) ||
    (isLiteral(value) && kind IN ( sh:Literal, sh:BlankNodeOrLiteral, sh:IRIOrLiteral ) ) ||
    (isBlank(value)   && kind IN ( sh:BlankNode, sh:BlankNodeOrIRI, sh:BlankNodeOrLiteral ) )  
}

function xsd:boolean sh:minLength(dt:graph shape, s, m){
    ! isBlank(s) && coalesce(strlen(s) >= m, false) 
}

function xsd:boolean sh:maxLength(shape, s, m){
    ! isBlank(s) && coalesce(strlen(s) <= m, false) 
}

function xsd:boolean sh:minInclusive(shape, o, m){
    o >= m
}

function xsd:boolean sh:minExclusive(shape, o, m){
    o > m
}

function xsd:boolean sh:maxInclusive(shape, o, m){
    o <= m
}

function xsd:boolean sh:maxExclusive(shape, o, m){
    o < m
}

function xsd:boolean sh:datatype(shape, o, dt){
    sh:datatype(o, dt)
}

function xsd:boolean sh:datatype(o, dt){
    if (isLiteral(o), return(datatype(o) = dt && isWellFormed(o)), false)
}

function xsd:boolean sh:minCount(s, m){
    s >= m
}

function xsd:boolean sh:maxCount(s, m){
    s <= m
}

function xsd:boolean sh:hasValue(shape, s, v) {
    s = v
}

@skip
function xsd:boolean sh:class(?shape, ?o, ?c){
  exists { ?o rdf:type/rdfs:subClassOf* ?c }
}

function xsd:boolean sh:classsh(?shape, ?o, ?c){
  exists { ?o rdf:type/rdfs:subClassOf* ?c }
}

function xsd:boolean sh:in(dt:graph ?shape, ?o, ?lv){
  exists { 
    # "declare" Node ?o to allow parameter passing
    values ?o { UNDEF }
    graph ?shape { values ?o { UNDEF }
        ?lv rdf:rest*/rdf:first ?v  
        filter (?o = ?v && ( ! isLiteral(?o) || datatype(?o) = datatype(?v)))
    }
  } 
}


function xsd:boolean sh:languageIn(dt:graph ?shape, ?o, ?lv){
  exists { 
    # "declare" Node ?o to allow parameter passing
    values ?o { UNDEF }
    bind (lang(?o) as ?lang)
    filter bound(?lang)
    graph ?shape { values ?lang { UNDEF }
        ?lv rdf:rest*/rdf:first ?l  
        filter langMatches(?lang, ?l)
    }
  } 
}

function xsd:boolean sh:node(dt:graph shape, o, cst){
    sh:testShapeCore(shape, cst, o)
}

function xsd:boolean sh:property(dt:graph shape, o, cst){
    sh:hasShape(shape, cst, true, o)
}

function xsd:boolean sh:qualifiedShape(subject, dt:graph shape, qsh){
    sh:testShapeCore(shape, qsh, subject)
}





function xsd:boolean sh:disjoint(dt:list l1, dt:list l2){
    for (x in l1){
            if (xt:member(x, l2)){
                return(false) 
            }     
    } ;
    return(true)
}

function xsd:boolean sh:equal(dt:list l1, dt:list l2){
    return (l1 = l2)
}

