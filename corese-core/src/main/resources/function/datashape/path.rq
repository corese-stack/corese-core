#
# SHACL Interpreter 
#
# Olivier Corby - Wimmics Inria I3S - 2016-2019
#

prefix sh:  <http://www.w3.org/ns/shacl#> 
prefix msh: <http://ns.inria.fr/shacl/>

@import <sparql.rq>

function sh:path(shape, sh, vis, ls, p) {
    sh:path(shape, sh, vis, ls, p, st:null, false)
}

# bound = true -> value is bound
function sh:path(shape, sh, vis, ls, p, value, isbound) {
    if (sh:trace(), xt:print("path:", ls, p), true);
  let (b1 = sh:generic1(shape, sh, vis, ls, p, value, isbound), 
       b2 = sh:generic2(shape, sh, vis, ls, p, value, isbound), 
       b3 = sh:generic4(shape, sh, vis, ls, p, value, isbound),
       b4 = sh:pathpattern(shape, sh, vis, ls, p, value, isbound),
       b5 = sh:sparqlvalid(shape, sh, vis, ls, p, value, isbound),
       b6 =      sh:sparql(shape, sh, vis, ls, p, value, isbound)
       ) {
       return (b1 && b2 && b3 && b4 && b5 && b6)
    }
}


#
# bound = true -> value is bound
# nodeList: target node list or target node (when inside boolean operator)
# p: the path
# oper=sh:nodeKind ; val=sh:IRI
#
function sh:generic1(shape, sh, vis, nodeList, p, value, isbound) {
    let (res = true) {
        for ((oper val) in sh:getConstraint(sh:generic, shape, sh)) {
            #xt:print("path:", oper, val, p, nodeList);
            for (s in dt:list(nodeList)) {
                for (o in (if (isbound, xt:list(value), sh:path(shape, s, p)))) {
                    let (suc = coalesce(
                        if (oper = sh:functioncst, 
                                funcall(val, shape, sh, s, p, o), 
                                funcall(oper, shape, o, val)), 
                        false)) {
                        if (oper in (sh:property), true, 
                                sh:report(oper, sh, if (oper = sh:node, val, st:null), shape, s, p, o, suc, vis)) ;
                        if (! suc) {
                            set(res = false) 
                        }
                    }
                }
            }
        } ;
        return (res)
    }
}


function sh:generic2(shape, sh, vis, nodeList, p, value, isbound) {
    let (res = true) {
        for ((oper val disjoint amin amax) in sh:getConstraint(sh:generic2, shape, sh)) {
            for (s in dt:list(nodeList)) {
                let (suc = coalesce(                    
                        sh:qualifiedValueShape(shape, sh, vis, s, p, val, disjoint, amin, amax) , 
                        false) ) {
                    if (! suc) {
                        set(res = false) 
                    }
                }
            }
        } ;
        return (res)
    }
}


function sh:generic4(shape, sh, vis, nodeList, p, value, isbound) {
    let (res = true) {
        for ((oper val) in sh:getConstraint(sh:generic4, shape, sh)) {
            for (s in dt:list(nodeList)) {
                let (suc = coalesce(
                    if (isbound, 
                        funcall(oper, shape, sh, vis, s, p, val, value),
                        funcall(oper, shape, sh, vis, s, p, val) ) , false)) {
                    if (! suc) {
                        set(res = false) 
                    }
                }
            }
        } ;
        return (res)
    }
}

# sh:cstpattern defined in constraint.rq
function sh:pathpattern (shape, sh, vis, nodeList, p, value, isbound) {
    let (res = true) {
        for ((oper flag) in sh:getConstraint(sh:cstpattern, shape, sh)) {  
            for (subject in dt:list(nodeList)) { 
                for (node in if (isbound, dt:list(value), sh:path(shape, subject, p))) {
                    let (suc = !isBlank(node) && coalesce(
                            if (isURI(flag), regex(node, oper), regex(node, oper, flag)),
                            false)) {    
                        if (!suc) {
                            set(res = false) ;
                            sh:report(sh:pattern, sh, shape, subject, p, node, suc, vis)
                        }
                    }
                }
            }
        } ;
        return (res)
    }
}


# sh:cstsparql defined in constraint.rq
function sh:sparql(shape, sh, vis, nodeList, p, value, isbound) {
    let (suc = true) {
        for ((cst define q mes) in sh:getConstraint(sh:cstsparql, shape, sh)) {  
            for (node in dt:list(nodeList)) {
                for (object in if (isbound, dt:list(value), sh:path(shape, node, p))) { 
                        if (sh:trace(), xt:print("path sparql:", node, p, object, q), true);
                        let (res = sh:mysparql(concat(define, q), sh, cst, shape, node, object, vis, 
                            coalesce(mes, st:null), bound(mes))) {
                            if (res, true, set(suc = false))
                        } 
                    } 
                }
        } ;
        return (suc)
    }
}


# *******************************************

#
# Retrieve properties of constraint sh using a query, do it once
# they are stored as a list in a map by sh:getConstraint defined in core.rq
#

function sh:generic(shape, sh) {
    let (select ?shape ?sh (aggregate(xt:list(?oper, ?val)) as ?list) where {
        graph ?shape { 
        values ?oper { 
                sh:minLength sh:maxLength sh:datatype sh:minInclusive sh:minExclusive sh:maxInclusive sh:maxExclusive 
                sh:nodeKind sh:class 
                sh:in sh:languageIn sh:node sh:property
                # extension with LDScript function that returns xsd:boolean. sh:functioncst has more parameters (see sh:validURI function/datashape/operator.rq) 
                sh:function sh:functioncst
        }
        ?sh ?oper ?val 
        }
        } 
        
    ) {
        return(list)
    }
}

function sh:generic2(shape, sh) {
    let (select ?shape ?sh 
        (aggregate(xt:list(sh:qualifiedValueShape, ?qsh, 
            coalesce(disjoint, false), coalesce(?min, 0), coalesce(?max, -1))) as ?list) 
        where {
            graph ?shape {  
                ?sh sh:qualifiedValueShape ?qsh
                optional { ?sh sh:qualifiedMinCount ?min }
                optional { ?sh sh:qualifiedMaxCount ?max }
                optional { ?sh sh:qualifiedValueShapesDisjoint ?disjoint }
            }
        } ) {
        return(list)
    }
}


function sh:generic4(shape, sh) {
    let (select ?shape ?sh (aggregate(xt:list(?oper, ?val)) as ?list) where {
        graph ?shape {  
            values ?oper { 
                sh:equals sh:disjoint sh:and sh:or sh:xone sh:not
                sh:maxCount sh:minCount
                sh:hasValue sh:uniqueLang sh:lessThan sh:lessThanOrEquals
            }
            ?sh ?oper ?val  
            filter if (?oper = sh:uniqueLang, sameTerm(?val, true), true)
        }
        } ) {
        return(list)
    }
}


#
# called when start
# within xt:focus(?shape, sh:sibling())
# record sibling qualifiedValueShape in a table
#
function sh:sibling() {
    for (select  ?qsh ?list where {
            select ?qsh (aggregate(xt:list(?sibling, ?path)) as ?list) 
            where {
                select distinct ?qsh ?sibling ?path
                where {
                    ?root sh:property [ sh:qualifiedValueShape ?qsh ];
                          sh:property [ sh:qualifiedValueShape ?sibling ; sh:path ?path ]  
                    filter (?sibling != ?qsh)
                }
            }
            group by ?qsh
        } ) {
            if (bound(?qsh), sh:setConstraint(sh:sibling, ?qsh, ?list), true) 
    } ;
    return (true)
}


# ************** operators


function sh:qualifiedValueShape (shape, sh, vis, s, p, qsh, disjoint, amin, amax) {
    let (list  = sh:qualified(shape, qsh, s, p),
         qlist = if (coalesce(disjoint, false), 
            # remove elements that are in sibling shapes
            mapfindlist(sh:disjoint, list, xt:list(shape), qsh, s), list),
         suc1 = xt:size(qlist) >= amin, 
         suc2 = if (amax = -1, true, xt:size(qlist) <= amax))
    {
        sh:report(sh:qualifiedMinCount, sh, shape, s, p, s, suc1, vis) ;
        sh:report(sh:qualifiedMaxCount, sh, shape, s, p, s, suc2, vis) ;
        return (suc1 && suc2)
    }
}

#
# test disjointness of subject ?s value ?o with ?qsh sibling shapes
# for each sibling shape ?sh, compute ?list of values and test ?o not in ?list
#
function sh:disjoint(o, shape, qsh, s){
   for ((sh, path) in sh:getConstraint(sh:sibling, qsh)){
        if (xt:member(o, sh:qualified(shape, sh, s, path))){
            return (false)
        }        
   } ;
   return (true)
}

#
# Return the list of value nodes that match qualified shape qsh 
#
function sh:qualified(shape, qsh, s, p){
     let (list = sh:path(shape, s, p)) {
        mapfindlist(sh:qualifiedShape, list, xt:list(shape), qsh)
     }
}











function sh:lessThan(shape, sh, vis, s, p, q){
    sh:lessThanList(shape, sh, vis, s, p, q, xt:objects(s, p), false, sh:lessThan)
}

function sh:lessThan(shape, sh, vis, s, p, q, o){
    sh:lessThanList(shape, sh, vis, s, p, q, dt:list(o), false, sh:lessThan)
}

function sh:lessThanOrEquals(shape, sh, vis, s, p, q){
    sh:lessThanList(shape, sh, vis, s, p, q, xt:objects(s, p), true, sh:lessThanOrEquals)
}

function sh:lessThanOrEquals(shape, sh, vis, s, p, q, o){
    sh:lessThanList(shape, sh, vis, s, p, q, dt:list(o), true, sh:lessThanOrEquals)
}

function sh:lessThanList(shape, sh, vis, s, p, q, list, leq, oper){
    let (suc = true) {
        for (o in list) {
            for (v in xt:objects(s, q)) {
                let (res = coalesce(if (leq, o <= v, o < v), false)) {
                    sh:report(oper, sh, shape, s, p, o, res, vis) ;
                    if (! res) {
                        set(suc = false)
                    } 
                }
            }
        } ;
        return (suc)
    }
}






function sh:uniqueLang (shape, sh, vis, s, p, v, o){
    sh:uniqueLang (shape, sh, vis, s, p, v)
}

function sh:uniqueLang (shape, sh, vis, s, p, v){
    let (suc = true, amap = xt:map(),
         nodeList = sh:path(shape, s, p),
         nodeLang = mapfindlist(lambda(value) { coalesce(lang(value) != "", false) }, nodeList)) {
         
         for (value in nodeLang) {
            let (lan = lang(value)) {
                xt:set(amap, lan, coalesce(xt:get(amap, lan), 0) + 1)
            }
         } ;
         
         for ((lan value) in amap) {
            let (res = value = 1) {
                if (res, true, set(suc = false));
                sh:report(sh:uniqueLang, sh, shape, s, p, lan, res, vis)
            }
         } ;
         
        return (suc)
    }
}



function sh:hasValue (shape, sh, vis, s, p, v) {
    let (suc = sh:hasValue(v, sh:path(shape, s, p))) {
        sh:report(sh:hasValue, sh, shape, s, p, v, suc, vis) ;
        return (suc)
    }
}

function sh:hasValue (object, list) {
    for (value in list) {
        if (coalesce(object = value, false), return(true), true)
    } ;
    return (false)
}




function sh:hasValue (shape, sh, vis, s, p, v, o) {
    sh:hasValue (shape, sh, vis, s, p, v)
}



function sh:minCount (shape, sh, vis, s, p, m, o) {
    sh:minCount (shape, sh, vis, s, p, m)
}

function sh:maxCount (shape, sh, vis, s, p, m, o) {
    sh:maxCount (shape, sh, vis, s, p, m)
}

function sh:minCount (shape, sh, vis, s, p, m) {
    let (val = xt:size(sh:path(shape, s, p)),
         suc = val >= m) { 
        sh:report(sh:minCount, sh, shape, s, p, val, suc, vis);
        return(suc)
    }
}

function sh:maxCount (shape, sh, vis, s, p, m) {
    let (val = xt:size(sh:path(shape, s, p)),
         suc = val <= m) { 
        sh:report(sh:maxCount, sh, shape, s, p, val, suc, vis);
        return(suc)
    }
}





function sh:disjoint (shape, sh, vis, s, p, q) {
    let (res = true, 
         l1 = sh:path(shape, s, p),
         l2 = sh:path(shape, s, q)) {
        for (o in l1) {
            let (suc = ! xt:member(o, l2)) {
                sh:report(sh:disjoint, sh, shape, s, p, o, suc, vis) ;
                set (res = res && suc)
            }
        } ;
        return (res)
    }
}

function sh:disjoint (shape, sh, vis, s, p, q, o) {
    let (l1 = sh:path(shape, s, p),
         l2 = sh:path(shape, s, q)) {
        if (xt:member(o, l1)) {
            let (suc = ! xt:member(o, l2)) {
                sh:report(sh:disjoint, sh, shape, s, p, o, suc, vis) ;
                return (suc)
            }
        } ;
        return (true)
    }
}






function sh:equals (shape, sh, vis, s, p, q) {
    let (l1 = sh:path(shape, s, p), 
         l2 = sh:path(shape, s, q)) {         
         let (b1 = sh:myequals (shape, sh, vis, s, p, q, l1, l2),
              b2 = sh:myequals (shape, sh, vis, s, p, q, l2, l1)) {
        return (b1 && b2)
        }
    }
}

function sh:myequals (shape, sh, vis, s, p, q, l1, l2) {
    let (res = true) {
        for (o in l1) {
            let (suc = xt:member(o, l2)) {
                 sh:report(sh:equals, sh, shape, s, p, o, suc, vis) ;
                 set(res = res && suc) 
            }
        } ;
        return (res)
    }
}


function sh:equals (shape, sh, vis, s, p, q, o) {
    let (l1 = sh:path(shape, s, p), 
         l2 = sh:path(shape, s, q),
         b1 = if (xt:member(o, l2), sh:equal (shape, sh, vis, s, p, q, o, l1), true),
         b2 = if (xt:member(o, l1), sh:equal (shape, sh, vis, s, p, q, o, l2), true)) {
        return (b1 && b2)
    }
}

function sh:equal (shape, sh, vis, s, p, q, o, l) {
    let (suc = xt:member(o, l)) {
        sh:report(sh:equals, sh, shape, s, p, o, suc, vis) ;
        return (suc)
    }
}





function sh:not (shape, sh, vis, s, p, cst) {
    let (res = true) {
        for (o in sh:path(shape, s, p)) {
            let (suc = ! sh:path(shape, cst, false, s, p, o, true)) {
                sh:report(sh:not, sh, shape, s, p, o, suc, vis);
                set (res = res && suc)
            }
        } ;
        return (res)
    }
}


function sh:and (shape, sh, vis, s, p, and) {
    msh:boolean (sh:and, shape, sh, vis, s, p, and)
}

function sh:or (shape, sh, vis, s, p, and) {
    msh:boolean (sh:or, shape, sh, vis, s, p, and)
}

function sh:xone (shape, sh, vis, s, p, and) {
    msh:boolean (sh:xone, shape, sh, vis, s, p, and)
}

function msh:boolean (oper, shape, sh, vis, s, p, and) {
    let (res = true) {
        for (o in sh:path(shape, s, p)) {
            let (suc = coalesce(funcall(oper, and, s, p, o, shape), false)) { 
                if (suc, true, sh:report(oper, sh, shape, s, p, o, suc, vis));
                set (res = res && suc)
            }
        };
        return (res)
    }
}


function sh:not (shape, sh, vis, s, p, cst, o) {
    let (l = sh:path(shape, s, p)) {
        if (xt:member(o, l)) {
            let (suc = ! sh:path(shape, cst, false, s, p, o, true)) {
                sh:report(sh:not, sh, shape, s, p, o, suc, vis);
                return(suc)
            }
        } ;
        return (true)
    }
}


function sh:and (shape, sh, vis, s, p, and, o) {
    msh:boolean (sh:and, shape, sh, vis, s, p, and, o)
}

function sh:or (shape, sh, vis, s, p, and, o) {
    msh:boolean (sh:or, shape, sh, vis, s, p, and, o)
}

function sh:xone (shape, sh, vis, s, p, and, o) {
    msh:boolean (sh:xone, shape, sh, vis, s, p, and, o)
}

function msh:boolean (oper, shape, sh, vis, s, p, and, o) {
    let (l = sh:path(shape, s, p)) {
        if (xt:member(o, l)) {
            let (suc = coalesce(funcall(oper, and, s, p, o, shape), false)) { 
                sh:report(oper, sh, shape, s, p, o, suc, vis);
                return (suc)
            }
        };
        return (true)
    }
}





# used by predicate/path 
# count failure
function xsd:boolean sh:and(and, s, p, o, dt:graph shape){
    (sh:bool(and, s, p, o, shape, 0, 1) = 0)
}

# used by predicate/path 
# count success
function xsd:boolean sh:or(or, s, p, o, dt:graph shape){
    (sh:bool(or, s, p, o, shape, 1, 0)  > 0)
}

# used by predicate/path 
# count success
function xsd:boolean sh:xone(or, s, p, o, dt:graph shape){
    (sh:bool(or, s, p, o, shape, 1, 0)  = 1)
}

function xsd:integer sh:bool(sh:NodeShape ?sh, ?s, ?p, ?o, dt:graph ?shape, xsd:integer ?suc, xsd:integer ?fail) {
   let (cc = 0) {
        for ((cst prop) in sh:getConstraint(sh:pathboolean, shape, sh)) {
            let (res = if (prop, sh:core(shape, cst, false, xt:list(o)),
                                 sh:path(shape, cst, false, s, p, o, true))) 
            {
                 set (cc = cc +  if (res, suc, fail))  
            }
        } ;
        return (cc)
    }
}

function sh:pathboolean(shape, sh) {
     let ( 
        SELECT ?sh  ?shape (aggregate(xt:list(?cst, bound(?prop))) as ?list)
		WHERE {
            graph ?shape { 
                ?sh rdf:rest*/rdf:first ?cst
				optional { ?cst sh:property|sh:path|sh:closed ?prop }
            } } ) { 
            return (list)
        }
}












