prefix sh:  <http://www.w3.org/ns/shacl#> 
prefix msh: <http://ns.inria.fr/shacl/>
prefix java: <http://www.w3.org/ns/shacl#> 

function sh:operator(oper, val, shape, sh, s, p, o) {
    if (oper = sh:functioncst,  
        funcall(val, shape, sh, s, p, o), 
        funcall(oper, shape, o, val))
}


# bound = true -> value is bound
function sh:generic(shape, sh, vis, ls, p, value, isbound) {
  let (b1 = sh:generic1(shape, sh, vis, ls, p, value, isbound), 
       b2 = sh:generic2(shape, sh, vis, ls, p, value, isbound), 
       b3 = sh:generic4(shape, sh, vis, ls, p, value, isbound)) {
       return (b1 && b2 && b3)
    }
}

# bound = true -> value is bound
function sh:generic1(shape, sh, vis, ls, p, value, isbound) {
    let (res = true) {
        for ((oper val) in sh:getConstraint(sh:generic, shape, sh)) {
            for (s in if (isExtension(ls), ls, xt:list(ls))) {
                for (o in (if (isbound, xt:list(value), sh:path(shape, s, p)))) {
                    let (suc = coalesce(sh:operator(oper, val, shape, sh, s, p, o), false)) {
                        if (oper in (sh:property), true, st:report(oper, sh, shape, s, p, o, suc, vis)) ;
                        if (! suc) {
                            set(res = false) 
                        }
                    }
                }
            }
        } ;
        return (res)
    }
}



function sh:generic2(shape, sh, vis, ls, p, value, isbound) {
    let (res = true) {
        for ((oper val) in sh:getConstraint(sh:generic2, shape, sh)) {
            for (s in if (isExtension(ls), ls, xt:list(ls))) {
                let (suc = coalesce(
                    if (isbound, 
                        # call template in current transformation st:dspath
                        st:call-template(oper, shape, sh, vis, s, p, val, value),
                        st:call-template(oper, shape, sh, vis, s, p, val) ), 
                    false) ) {
                    if (! suc) {
                        set(res = false) 
                    }
                }
            }
        } ;
        return (res)
    }
}


function sh:generic4(shape, sh, vis, ls, p, value, isbound) {
    let (res = true) {
        for ((oper val) in sh:getConstraint(sh:generic4, shape, sh)) {
            for (s in if (isExtension(ls), ls, xt:list(ls))) {
                let (suc = coalesce(
                    if (isbound, 
                        funcall(oper, shape, sh, vis, s, p, val, value),
                        funcall(oper, shape, sh, vis, s, p, val) ) , false)) {
                    if (! suc) {
                        set(res = false) 
                    }
                }
            }
        } ;
        return (res)
    }
}






# record relevant properties of sh as a list in a table
function sh:getConstraint(name, shape, sh) {
    coalesce(st:cget(name, sh), st:cset(name, sh, funcall(name, shape, sh)))
}

# properties for path/generic.rq
function sh:generic(shape, sh) {
    let (select ?shape ?sh (aggregate(xt:list(?q, ?m)) as ?list) where {
        graph ?shape {  
            values ?q { 
                sh:minLength sh:maxLength sh:datatype sh:minInclusive sh:minExclusive sh:maxInclusive sh:maxExclusive 
                sh:nodeKind sh:class 
                sh:in sh:languageIn sh:node sh:property
                # extension with LDScript function that returns xsd:boolean. sh:functioncst has more parameters (see sh:validURI function/datashape/operator.rq) 
                sh:function sh:functioncst
            }
            ?sh ?q ?m    
        }
    } ) {
        return(list)
    }
}

# properties for path/generic2.rq
function sh:generic2(shape, sh) {
    let (select ?shape ?sh (aggregate(xt:list(?oper, ?b)) as ?list) where {
        graph ?shape {  
            values ?oper {       
            sh:pattern sh:uniqueLang sh:hasValue sh:lessThanOrEquals sh:lessThan  
            sh:qualifiedValueShape sh:sparql
            }
            ?sh ?oper ?b  
            filter if (?oper = sh:uniqueLang, sameTerm(?b, true), true)
        }
        } ) {
        return(list)
    }
}

# properties for path/generic4.rq
function sh:generic4(shape, sh) {
    let (select ?shape ?sh (aggregate(xt:list(?oper, ?b)) as ?list) where {
        graph ?shape {  
            values ?oper { 
                sh:equals sh:disjoint sh:and sh:or sh:xone sh:not
                sh:maxCount sh:minCount
            }
            ?sh ?oper ?b  
        }
        } ) {
        return(list)
    }
}



function sh:minCount (shape, sh, vis, s, p, m, o) {
    sh:minCount (shape, sh, vis, s, p, m)
}

function sh:maxCount (shape, sh, vis, s, p, m, o) {
    sh:maxCount (shape, sh, vis, s, p, m)
}

function sh:minCount (shape, sh, vis, s, p, m) {
    let (val = xt:size(sh:path(shape, s, p)),
         suc = val >= m) { 
        st:report(sh:minCount, sh, shape, s, p, val, suc, vis);
        return(suc)
    }
}

function sh:maxCount (shape, sh, vis, s, p, m) {
    let (val = xt:size(sh:path(shape, s, p)),
         suc = val <= m) { 
        st:report(sh:maxCount, sh, shape, s, p, val, suc, vis);
        return(suc)
    }
}





function sh:disjoint (shape, sh, vis, s, p, q) {
    let (res = true, 
         l1 = sh:path(shape, s, p),
         l2 = sh:path(shape, s, q)) {
        for (o in l1) {
            let (suc = ! xt:member(o, l2)) {
                st:report(sh:disjoint, sh, shape, s, p, o, suc, vis) ;
                set (res = res && suc)
            }
        } ;
        return (res)
    }
}

function sh:disjoint (shape, sh, vis, s, p, q, o) {
    let (l1 = sh:path(shape, s, p),
         l2 = sh:path(shape, s, q)) {
        if (xt:member(o, l1)) {
            let (suc = ! xt:member(o, l2)) {
                st:report(sh:disjoint, sh, shape, s, p, o, suc, vis) ;
                return (suc)
            }
        } ;
        return (true)
    }
}






function sh:equals (shape, sh, vis, s, p, q) {
    let (l1 = sh:path(shape, s, p), 
         l2 = sh:path(shape, s, q)) {         
         let (b1 = sh:myequals (shape, sh, vis, s, p, q, l1, l2),
              b2 = sh:myequals (shape, sh, vis, s, p, q, l2, l1)) {
        return (b1 && b2)
        }
    }
}

function sh:myequals (shape, sh, vis, s, p, q, l1, l2) {
    let (res = true) {
        for (o in l1) {
            let (suc = xt:member(o, l2)) {
                 st:report(sh:equals, sh, shape, s, p, o, suc, vis) ;
                 set(res = res && suc) 
            }
        } ;
        return (res)
    }
}


function sh:equals (shape, sh, vis, s, p, q, o) {
    let (l1 = sh:path(shape, s, p), 
         l2 = sh:path(shape, s, q),
         b1 = if (xt:member(o, l2), sh:equal (shape, sh, vis, s, p, q, o, l1), true),
         b2 = if (xt:member(o, l1), sh:equal (shape, sh, vis, s, p, q, o, l2), true)) {
        return (b1 && b2)
    }
}

function sh:equal (shape, sh, vis, s, p, q, o, l) {
    let (suc = xt:member(o, l)) {
        st:report(sh:equals, sh, shape, s, p, o, suc, vis) ;
        return (suc)
    }
}








########################## from path profile

function sh:not (shape, sh, vis, s, p, cst) {
    let (res = true) {
        for (o in sh:path(shape, s, p)) {
            let (suc = ! sh:hasPath(shape, cst, false, s, p, o)) {
                st:report(sh:not, sh, shape, s, p, o, suc, vis);
                set (res = res && suc)
            }
        } ;
        return (res)
    }
}


function sh:and (shape, sh, vis, s, p, and) {
    msh:boolean (sh:and, shape, sh, vis, s, p, and)
}

function sh:or (shape, sh, vis, s, p, and) {
    msh:boolean (sh:or, shape, sh, vis, s, p, and)
}

function sh:xone (shape, sh, vis, s, p, and) {
    msh:boolean (sh:xone, shape, sh, vis, s, p, and)
}

function msh:boolean (oper, shape, sh, vis, s, p, and) {
    let (res = true) {
        for (o in sh:path(shape, s, p)) {
            let (suc = coalesce(funcall(oper, and, s, p, o, shape), false)) { 
                st:report(oper, sh, shape, s, p, o, suc, vis);
                set (res = res && suc)
            }
        };
        return (res)
    }
}


function sh:not (shape, sh, vis, s, p, cst, o) {
    let (l = sh:path(shape, s, p)) {
        if (xt:member(o, l)) {
            let (suc = ! sh:hasPath(shape, cst, false, s, p, o)) {
                st:report(sh:not, sh, shape, s, p, o, suc, vis);
                return(suc)
            }
        } ;
        return (true)
    }
}


function sh:and (shape, sh, vis, s, p, and, o) {
    msh:boolean (sh:and, shape, sh, vis, s, p, and, o)
}

function sh:or (shape, sh, vis, s, p, and, o) {
    msh:boolean (sh:or, shape, sh, vis, s, p, and, o)
}

function sh:xone (shape, sh, vis, s, p, and, o) {
    msh:boolean (sh:xone, shape, sh, vis, s, p, and, o)
}

function msh:boolean (oper, shape, sh, vis, s, p, and, o) {
    let (l = sh:path(shape, s, p)) {
        if (xt:member(o, l)) {
            let (suc = coalesce(funcall(oper, and, s, p, o, shape), false)) { 
                st:report(oper, sh, shape, s, p, o, suc, vis);
                return (suc)
            }
        };
        return (true)
    }
}





# used by predicate/path 
# count failure
function xsd:boolean sh:and(and, s, p, o, dt:graph shape){
    (sh:bool(and, s, p, o, shape, 0, 1) = 0)
}

# used by predicate/path 
# count success
function xsd:boolean sh:or(or, s, p, o, dt:graph shape){
    (sh:bool(or, s, p, o, shape, 1, 0)  > 0)
}

# used by predicate/path 
# count success
function xsd:boolean sh:xone(or, s, p, o, dt:graph shape){
    (sh:bool(or, s, p, o, shape, 1, 0)  = 1)
}

# property (predicate or path)
# ?fun = sh:hasPath
function xsd:integer sh:bool(sh:NodeShape ?sh, ?s, ?p, ?o, dt:graph ?shape, xsd:integer ?suc, xsd:integer ?fail){
    let ( 
        SELECT ?sh ?s ?p ?o ?shape ?suc ?fail (SUM(?val) AS ?count)
		WHERE {
			GRAPH ?shape {
				?sh rdf:rest*/rdf:first ?cst
				optional { ?cst sh:property|sh:path|sh:closed ?prop }
			}
			BIND (
                if (bound(?prop), 
                    java:testShapeCore(?shape, ?cst, ?o),
                    java:hasPath(?shape, ?cst, false, ?s, ?p, ?o))
			AS ?hasShape)
			BIND (IF (bound(?hasShape), IF (?hasShape, ?suc, ?fail), 'error') AS ?val) .
		}
		values (?s ?suc ?fail ?p ?o ) { (UNDEF UNDEF UNDEF UNDEF UNDEF) }) 
		{ return(?count) }
}
