#
# Data Shape Property Path Interpreter
# PP expressions are searched in graph ?shape 
#
# Olivier Corby - Wimmics Inria I3S - 2016
#
prefix sh:   <http://www.w3.org/ns/shacl#> 


#
# SHACL Path Compiler from RDF graph to list expression
#

#
# Rewrite Property Path shape expression as a LDScript list
#
# ([sh:zeroOrMorePath rdf:rest] rdf:first)
# ->
# (sh:sequence ((sh:zeroOrMorePath rdf:rest) rdf:first))
# URI may be URI of a subpath such as:
# [sh:path ex:parent] .
# ex:parent sh:alternativePath (ex:father ex:mother)
# sh:path (ai:location [ sh:service (<http://dbpedia.org/sparql> rdf:type ) )

@import <ppathext.rq>

function sh:path(dt:graph ?shape, ?exp) {

  if (isURI(?exp) || isLiteral(?exp)) { ?exp }
  else {
    let ( 
        select ?shape ?exp ?q ?path  where {
            graph ?shape { 
               # rdf:rest is for a sequence
               # values ?q { 
               #     rdf:rest sh:inversePath sh:alternativePath 
               #     sh:zeroOrMorePath sh:oneOrMorePath sh:zeroOrOnePath  
               #     sh:service sh:ldpath }
                ?exp ?q ?path   filter (?q not in (rdf:first))
            }
        } ) {
          
    if (! bound(?q)) { error() }   
    else if (?q = rdf:rest)    { return(xt:list(sh:sequence, sh:listsh(?shape, ?exp))) }
    else if (sh:extension(?exp, ?q)) { return (sh:extension(?shape, ?q, ?path)) }
    else { return(xt:list(?q, sh:path(?shape, ?path))) }
    }
  }
}


# [<http://dbpedia.org/sparql> (rdf:type)]
# test isBlank because a path element may be an URI which may have properties
# focus on local bnode 
function sh:extension(exp, q) {
    return (sh:statement(q) || sh:operator(q) || (isBlank(exp) && sh:usernamespace(q)))
}

function sh:statement(oper) {
    oper in (sh:service, sh:ldpath)
}

function sh:operator(oper) {
    sh:boolean(oper) || 
    oper in (sh:pattern, sh:nodeKind, sh:datatype, sh:minLength, sh:maxLength, sh:hasValue, sh:validURI)
}

function sh:boolean(oper) {
    oper in (sh:and, sh:or, sh:not)
}

function sh:usernamespace(oper) {
    ! mapany(rq:strstarts, oper, xt:list(rdf:, rdfs:, owl:, sh:))
}


# (us:location [sh:service (<http://dbpedia.org/sparql> rdf:type) ] )
# (us:location [<http://dbpedia.org/sparql> (rdf:type) ] )
# (us:location [sh:pattern 'dbpedia'] [<http://dbpedia.org/sparql> (rdf:type) ] ) 
#
function sh:extension(shape, oper, path) {
         if (sh:statement(oper))     { return(xt:list(oper,   sh:listsh(shape, path))) }
    else if (sh:operator(oper))      { return(sh:parseOperator(shape, oper, path)) }
    else if (sh:usernamespace(oper)) { return(xt:list(sh:service, xt:cons(oper, sh:listsh(shape, path)))) }
}



# oper = sh:pattern ; path = 'http://dbpedia' 
# return (sh:filter (sh:pattern 'http://dbpedia'))
function sh:parseOperator(shape, oper, path) {
    if (sh:boolean(oper), sh:parseBoolean(shape, oper, path),
        xt:list(sh:filter, xt:list(oper, path)))
}

# [sh:and ([sh:nodeKind sh:IRI] [sh:pattern 'dbpedia']) ]
# oper = sh:and ; path = list bnode 
function sh:parseBoolean(shape, oper, path) {
    let (list = sh:listsh(shape, path)) {
        xt:list(sh:filter, xt:list(sh:booleanoper(oper), list))
    }
}

function sh:booleanoper(oper) {
    if (oper = sh:and, sh:myand, if (oper = sh:or, sh:myor, sh:mynot))
}


#
# Rewrite recursively RDF list ?exp as a list
#
function dt:list sh:listsh(dt:graph ?shape, ?exp){
   let ( 
        select ?shape ?exp (aggregate(sh:path(?shape, ?e)) as ?l)  
        where { graph ?shape { ?exp rdf:rest*/rdf:first ?e }}) {
        return(?l)
    }
}

function dt:list sh:tolist(dt:graph ?shape, ?exp){
   let ( 
        select ?shape ?exp (aggregate(?e) as ?l)  
        where { graph ?shape { ?exp rdf:rest*/rdf:first ?e }}) {
        return(?l)
    }
}


#
# Return list of nodes related to node ?s by path ?p
# ?s is subject, ?p is PP expression
# ?s = us:John ; ?p = [sh:zeroOrMorePath foaf:knows]
#
function dt:list sh:path(dt:graph shape, s, p){    
    sh:path(shape, s, sh:getPath(shape, p), false)
}


#
# rewrite PP once as a list and record it
#
function sh:getPath(dt:graph shape, p){
   coalesce(st:cget(sh:path, p), st:cset(sh:path, p, sh:path(shape, p)))
}



# ********************************************************************************************

#
# Path expression interpreter
#


#
# Evaluate PP p as a list
# Return list of target nodes that match the path
# inv = true means within inverse path
#
function dt:list sh:path(dt:graph shape, s, p, xsd:boolean inv){
  if (isURI(p)){
     return(sh:pathProperty(shape, s, p, inv))
  }
  else {
    let ((oper path) = p) {      
      return(funcall(oper, shape, s, path, inv))
   }
  } 
}



function dt:list sh:zeroOrOnePath(dt:graph shape, s, p, xsd:boolean inv){
    let (l = sh:path(shape, s, p, inv)){
        if (xt:member(s, l), 
            return(l), 
            return(xt:cons(s, l)))
    }
}

function dt:list sh:zeroOrMorePath(dt:graph shape, s, p, xsd:boolean inv){
    sh:rec(shape, s, p, xt:list(s), inv)
}

function dt:list sh:oneOrMorePath(dt:graph shape, s, p, xsd:boolean inv){
    sh:rec(shape, s, p, xt:list(), inv)
}

#
# ?p is a PP expression exp
# compute exp*
# ?res is the list of nodes already reached by exp*
# ?res prevents loops
#
function dt:list sh:rec(dt:graph shape, s, p, dt:list res, xsd:boolean inv){
    let (l = sh:path(shape, s, p, inv)){
        if (xt:size(l) = 0){ return(res) }
        else {
            for (ee in l){
                if (! xt:member(ee, res)){
                    xt:add(res, ee) ; 
                    sh:rec(shape, ee, p, res, inv)
                }             
            } ;
            return(res)             
        }
    }
}


#
# s ^exp
# inverse PP expression
#
function dt:list sh:inversePath(dt:graph shape, s, p, xsd:boolean inv){
    sh:path(shape, s, p, ! inv)
}


#
# p is  a sequence list
#
function dt:list sh:sequence(dt:graph shape, s, p, xsd:boolean inv){
    if (inv) {
        return(sh:seqlist(shape, s, xt:reverse(p), inv))
    }
    else{
        return(sh:seqlist(shape, s, p, inv))
    }
}


#
# Recursive traversal of sequence list lp
# recurse on xt:rest(lp)
#
function dt:list sh:seqlist(dt:graph shape, node, dt:list lp, xsd:boolean inv){
    if (xt:size(lp) = 0){
        # reach end of sequence: add target node subject
        return(xt:list(node))
    }
    else {
        let (nodelist = sh:path(shape, node, xt:first(lp), inv), 
            res = xt:list()){
            for (next in nodelist){ 
                # merge removes duplicate nodes
                set(res = xt:merge(res, sh:seqlist(shape, next, xt:rest(lp), inv)))
            } ;
            return(res)
        }
    }
}

# p = (sh:sequence (exp .. exp))
function dt:list sh:alternativePath(dt:graph shape, s, p, xsd:boolean inv){
    let (l = xt:get(p, 1)) {
        return(mapmerge(sh:pathmap, l, xt:list(shape), s, inv))
    }
}

function dt:list sh:pathmap(l, dt:graph shape, s, xsd:boolean inv){
    sh:path(shape, s, l, inv)
}





function dt:list sh:pathProperty(shape, s, p, xsd:boolean inv){
    if (inv) {
        return(sh:inverse(s, p))
    }
    else {
        return(sh:predicate(s, p))    
    }
}



function dt:list sh:predicate(?s, ?p){
    let (select ?s ?p (aggregate(?o) as ?l) where  { ?s ?p ?o }){
        return(?l)
    }
}


function dt:list sh:inverse(?o, ?p){
    let (select ?o ?p (aggregate(?s) as ?l) where  { ?s ?p ?o }){
        return(?l)
    }
}




