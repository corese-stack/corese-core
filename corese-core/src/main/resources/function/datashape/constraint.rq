#
# SHACL Interpreter 
#
# Olivier Corby - Wimmics Inria I3S - 2016-2019
#

prefix sh:  <http://www.w3.org/ns/shacl#> 
prefix msh: <http://ns.inria.fr/shacl/>

function sh:constraint(shape, sh, vis, nodeList) {
    let (b1 = sh:constraint1 (shape, sh, vis, nodeList),
         b2 = sh:constraint2 (shape, sh, vis, nodeList),
         b3 = sh:cstpattern  (shape, sh, vis, nodeList),
         b4 = sh:cstsparql   (shape, sh, vis, nodeList)
         ) {
        return (b1 && b2 && b3 && b4)
    }
}

# shape sh has several operators with value, ex: oper=sh:datatype value=xsd:string
# operator defined as a function (in operator.rq) with same name
# operator executed as funcall(oper, value)
# list of (oper value) is computed once for each shape sh and stored in a table 
# sh:getConstraint retrieve the list (oper value)
# nodeList is either a list of nodes or a single node
# sh:report generates a validation report in case of error
#
function sh:constraint1 (shape, sh, vis, nodeList) {
    let (res = true) {
        for ((oper value) in sh:getConstraint(sh:cstgeneric1, shape, sh)) {  
            for (node in dt:list(nodeList)) {    
                let (suc = coalesce(if (oper = sh:functioncst,  
                    funcall(value, shape, sh, node), 
                    funcall(oper, shape, node, value)), false)) {
                        sh:report(oper, sh, if (oper = sh:node, value, st:null), shape, node, st:null, node, suc, vis) ;
                        if (suc, true, set(res = false))
                    }
            }
        } ;
        return (res)
    }
}


function sh:cstsparql (shape, sh, vis, nodeList) {
   let (res = true) {
        for ((cst define q mes) in sh:getConstraint(sh:cstsparql, shape, sh)) {  
            for (node in dt:list(nodeList)) {   
                if (sh:trace(), xt:print("cstsparql:", node, q), true);
                let (suc = coalesce(
                    sh:mysparql(concat(define, q), sh, cst, shape, node, node, vis, 
                        mes, isLiteral(mes)),
                    false)) {
                    if (suc, true, set(res = false))
                }
            }
        } ;
        return (res)
    }
}


function sh:constraint2 (shape, sh, vis, nodeList) {
    let (res = true) {
        for ((oper value) in sh:getConstraint(sh:cstgeneric2, shape, sh)) {  
            for (node in dt:list(nodeList)) {    
                let (suc = coalesce(funcall(oper, shape, sh, vis, node, value), false)) {
                    if (suc, true, set(res = false))
                }
            }
        } ;
        return (res)
    }
}

function sh:cstpattern (shape, sh, vis, nodeList) {
    let (res = true) {
        for ((oper flag) in sh:getConstraint(sh:cstpattern, shape, sh)) {  
            for (node in dt:list(nodeList)) { 
                let (suc = !isBlank(node) && coalesce(
                        if (isURI(flag), regex(node, oper), regex(node, oper, flag)),
                        false)) {    
                    sh:report(sh:pattern, sh, shape, node, st:null, node, suc, vis);
                    if (!suc) {
                        set(res = false) 
                    }
                }
            }
        } ;
        return (res)
    }
}




#
# Retrieve properties of constraints, thay are stored in a map by getConstraint
#
# 

function sh:cstpattern(shape, sh) {
    let (select ?shape ?sh (aggregate(xt:list(?exp, coalesce(?flag, st:null))) as ?list) where {
        graph ?shape {  
            ?sh sh:pattern ?exp   
            optional { ?sh sh:flags ?flag } 
        }
    } ) {
        return(list)
    }
}


function sh:cstgeneric(shape, sh, list) {
    let (select ?shape ?sh ?list (aggregate(xt:list(?q, ?m)) as ?res) where {
        graph ?shape {  
            values ?list {UNDEF}
            values ?q { unnest(?list) }
            ?sh ?q ?m    
        }
    } ) {
        return(res)
    }
}

function sh:cstgeneric1(shape, sh) {
    sh:cstgeneric(shape, sh, xt:list(
                sh:hasValue, sh:datatype, sh:minInclusive, sh:minExclusive, sh:maxInclusive, sh:maxExclusive, sh:minLength, sh:maxLength, sh:nodeKind, sh:node, sh:in, sh:languageIn, 
                sh:function, sh:functioncst))
}




function sh:cstsparql(shape, sh) {
    let (select * (aggregate (xt:list(cst, define, q, coalesce(mes, st:null))) as ?list)
        where {
        graph ?shape {  
                ?sh sh:sparql ?cst 
                ?cst sh:select ?q
                filter not exists { ?cst sh:deactivated true }
                optional { ?cst sh:message ?mes }
                
                # collect prefix definitions
                {
                    select ?cst 
                    (group_concat(concat("prefix ", ?pr, ": <", str(?ns), ">") ;  separator=" ") 
                    as ?define) 
                    where {
                        ?cst sh:prefixes/owl:imports*/sh:declare [ sh:prefix ?pr ; sh:namespace ?ns ] 
                    }
                    group by ?cst
                }
        } }
        ) {
        return(list)
        }
}


function sh:cstgeneric2(shape, sh) {
    sh:cstgeneric(shape, sh, xt:list(sh:class, sh:disjoint, sh:equals))
}







function sh:class (shape, sh, vis, s, ?c) {
    let (suc = exists { ?s rdf:type/rdfs:subClassOf* ?c } ) {
        sh:report(sh:class, sh, shape,  s, rdf:type, s, suc, vis) ;
        return (suc)
    }
}


function sh:disjoint (shape, sh, vis, s, p) {
    let (l = sh:path(shape, s, p), suc = ! xt:member(s, l)) {
        sh:report(sh:disjoint, sh, shape, s, p, s, suc, vis) ;
        return (suc)
    }
}

function sh:equals (shape, sh, vis, s, p) {
    let (l  = sh:path(shape, s, p),
         b1 = sh:equals1(shape, sh, vis, s, p, l),
         b2 = sh:equals2(shape, sh, vis, s, p, l)) {
            return (b1 && b2)
    }
}


function sh:equals1 (shape, sh, vis, s, p, l) {
    let (suc = xt:member(s, l)) {
        sh:report(sh:equals, sh, shape, s, p, s, suc, vis);
        return (suc)
    }
}

function sh:equals2 (shape, sh, vis, s, p, l) {
    let (res = true) {
        for (m in l) {
            let (suc = s = m) {
                sh:report(sh:equals, sh, shape, s, p, m, suc, vis);
                set (res = res && suc)
            }
        } ;
        return (res)
    }
}










