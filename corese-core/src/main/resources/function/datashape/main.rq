#
# SHACL Interpreter 
#
# Olivier Corby - Wimmics Inria I3S - 2016-2019
#
prefix sh:   <http://www.w3.org/ns/shacl#> 

@import <target.rq> <focus.rq> <ppath.rq> <operator.rq> <path.rq> <core.rq> <constraint.rq>


#
# main function
# Current graph is RDF graph
# shape is SHACL Shape graph (they can be the same graph)
# return validation report graph
#
function dt:graph sh:shacl() {
   if (sh:trace(), xt:print("shacl:"), true);
   sh:shacl(xt:graph())
}

function dt:graph sh:shacl(dt:graph shape) {
   if (sh:trace(), xt:print("shacl:"), true);
   sh:shacl(shape, sh:focus(shape))
}

function dt:graph sh:shaclshape(sh) {
   if (sh:trace(), xt:print("shaclshape:", sh), true);
   sh:shacl(xt:graph(), sh:focus(xt:graph(), sh))
}

#
# evaluate sh(node) even if node is not into sh target
#
function dt:graph sh:shaclshape(sh, node) {
   if (sh:trace(), xt:print("shaclshape:", sh, node), true);
   sh:shacl(xt:graph(), xt:list(xt:list(sh, xt:list(node))))
}

function dt:graph sh:shaclnode(node) {
   if (sh:trace(), xt:print("shaclnode:", node), true);
   sh:shacl(xt:graph(), sh:focusnode(xt:graph(), node))
}

#
# focus = mappings or list(sh=nodeShape; list=targetNodeList)
#
function dt:graph sh:shacl(dt:graph shape, focus) {
    sh:start(shape) ;
    let (suc = sh:eval(shape, focus)) {
        sh:success(suc);
        sh:finish() ;
        return (validationReport)
    }
}

function sh:focuslist(dt:graph shape) {
    sh:list(sh:focus(shape))
}


function xsd:boolean sh:conform(?g) {
    let (select * where { graph ?g { ?x sh:conforms ?b } } ) {
        return(?b)
    }
}


function sh:trace(shape, mapmap) {
        for ((key val) in mapmap) {
            if (key != sh:def) {
                xt:print(key);
                for ((sh list) in val) {
                    if (isExtension(list) && xt:size(list) > 0) {
                        xt:print(sh, ":", list);
                        if (isBlank(sh)) {
                            xt:print(xt:turtle(shape, sh))
                        }
                    }
                } ;
                xt:print("__")
            }
        } ;
        return (true)
}

#
# focus = mappings or list(sh=nodeShape; list=targetNodeList)
#
function sh:eval(shape, focus) {
    let (suc = true) {
        for ((sh list) in focus) {
            if (sh:trace(), 
                xt:print("target:", coalesce(sh, "undef"), xt:size(list), list), true);
            if (bound(sh) && xt:size(list) > 0) {
                let (res = sh:core(shape, sh, true, list)) {
                    if (res, true, set(suc = false))
                }
            }
        } ;
        return (suc)
    }
}


# start
function sh:start(shape) {
    # transformer visitor for legacy
    st:visit(st:start, st:trace) ;
    # validation report graph
    set(validationReport = query(construct where {})) ;
    set(mapmap = xt:map()) ;
    set(recordmapsuc = xt:map());
    set(recordmapfail = xt:map());
    coalesce(sh:trace(), sh:trace(!true));
    sh:init();
    if (shape = xt:graph(), sh:sibling(), xt:focus(shape, sh:sibling())) ;
    return (true)
}

# declare report graph to transformer visitor graph, use case: shape workflow
function sh:finish() {
    #sh:tracefinish();
    st:visit(st:trace, st:graph, validationReport) 
}


function xsd:boolean sh:hasShape(dt:graph shape, sh:NodeShape sh, xsd:boolean vis, ls) {
    sh:core(shape, sh, vis, ls)
}







# when true, generate validation report for sh:node constraints and one report for sh:node 
# otherwise, generate only one report for sh:node (default)
function sh:detail(xsd:boolean bb) {
    set(detailShapeMode = bb)
}

function sh:detail() {
    return (bound(detailShapeMode) && detailShapeMode)
}

#function sh:test(){ st:get(st:test, true) }


function sh:hasConstraint(name, sh) {
    xt:has(sh:getmap(name), sh)
}

# get relevant properties of sh  in a table
function sh:getConstraint(name, sh) {
    xt:get(sh:getmap(name), sh)
}

# record relevant properties of sh  in a table
function sh:setConstraint(name, sh, value) {
    xt:set(sh:getmap(name), sh, value)
}


function sh:getmap(name) {
    if (xt:has(mapmap, name), xt:get(mapmap, name), xt:set(mapmap, name, xt:map()))
}

function sh:getrecordmap(name, suc) {
if (suc,
    if (xt:has(recordmapsuc, name),  xt:get(recordmapsuc, name),  xt:set(recordmapsuc, name, xt:map())),
    if (xt:has(recordmapfail, name), xt:get(recordmapfail, name), xt:set(recordmapfail, name, xt:map())))   
}


function xsd:boolean sh:safe(dt:graph shape, sh, xsd:boolean suc) {
    suc
}

function xsd:boolean sh:report(name, s, xsd:boolean suc, xsd:boolean vis) {
    if (vis) {
        sh:visit(name, s, suc)
    } ;
    return (true)
}

#
# suc is success/failure of the shape
# vis true means generate a ValidationResult
#
function xsd:boolean sh:report(name,  sh, dt:graph shape, foc, p, o, xsd:boolean suc, xsd:boolean vis){
    sh:report(name, sh, st:null, shape, foc, p, o, suc, vis)
}

function xsd:boolean sh:report(name, sh:NodeShape sh, dt:graph shape, foc, xsd:boolean suc, xsd:boolean vis){
    sh:report(name, sh, shape, foc, st:null, st:null, suc, vis)
}

function xsd:boolean sh:report(name,  sh, cst, dt:graph shape, foc, p, o, xsd:boolean suc, xsd:boolean vis){
    sh:record(name,  sh, cst, shape, foc, p, o, suc, vis);
    if (vis && ! suc) { 
        sh:result(name, sh, cst, shape, foc,  p, o) ;
        sh:visit(name, foc, suc)
    } ;
    return(true)
}

#
# Additional report
#
function sh:record(name,  sh, cst, dt:graph shape, foc, p, o, xsd:boolean suc, xsd:boolean vis) {
    if (vis) {
        let (amap = sh:getrecordmap(name, suc)) {
            xt:set(amap, sh,          coalesce(xt:get(amap, sh), 0) + 1) ;
            xt:set(amap, sh:subtotal, coalesce(xt:get(amap, sh:subtotal), 0) + 1)  
        } ;
        let (bmap = sh:getrecordmap(sh:total, suc)) {
             xt:set(bmap, sh:total, coalesce(xt:get(bmap, sh:total), 0) + 1)
        }         
    } ;
    return(true)
}

function sh:tracerecord(shape, mapmap) {
        for ((key val) in mapmap) {
            if (key != sh:def) {
                xt:print(key);
                for ((sh value) in val) {
                        xt:print(sh, ":", value) ;
                        if (isBlank(sh)) {
                            xt:print(xt:turtle(shape, sh))
                        }
                } ;
                xt:print("__")
            }
        } ;
        return (true)
}



function sh:value(v){
    return(if (isURI(v) && v = st:null, error(), v))
}


function xsd:boolean sh:trace() {
    return (coalesce(shaclTrace, false))
}

function xsd:boolean sh:trace(xsd:boolean bb) {
    set (shaclTrace = bb )
}

# finish
function xsd:boolean sh:success(xsd:boolean bb) {
    if (bb) {
        let (g = 
            construct { [] a sh:ValidationReport ; sh:conforms true }
            where { }
            ) {
            us:insert(g, validationReport)
        }
    } ;
    return (true)
}

# insert report element g into report
function us:insert(dt:graph g, dt:graph report) {
    for ((s p o) in g) {
       #xt:focus(report, xt:insert(s, p, o))
        xt:insert(report, s, p, o)
    } 
}




#
# create a validation result  graph
# stored in the visitor graph
# get it with st:visitedGraph()
# sh :  the shape
# cst : the constraint in case of sh:node
#
function xsd:boolean sh:result(?name, ?sh, ?cst, dt:graph ?shape, ?foc, ?p, ?o){
    let (g = 
       construct {
        ?bnode a sh:ValidationReport ; 
            sh:result ?r ; 
            sh:conforms false .
        
        ?r rdf:type sh:ValidationResult ;
            sh:resultSeverity ?sev ;
            sh:focusNode ?foc ;
            sh:focusNodeDetail ?focDetail ;
            sh:resultPath ?pathDetail ; 
            #sh:resultPath ?pp ; 
            #sh:pathDetail ?pathDetail ; 
            sh:value ?oo ;
            sh:valueDetail ?valueDetail ;
            sh:resultMessage ?mes ;
            sh:sourceConstraintComponent ?def ;
            sh:sourceShape ?sh
        } 
        where { 
            bind(uuid() as ?r)
            bind(coalesce(sh:isdefby(?name), ?name) as ?def)
            bind(coalesce(xt:value(?shape, ?sh, sh:severity), sh:Violation) as ?sev)
            bind(sh:getMessage(?shape, ?sh, ?cst) as ?m)
            bind(if (bound(?m), ?m, concat("Fail at: ", sh:createMessage(?shape, ?sh, ?cst))) as ?mes)
            bind(sh:value(?p) as ?pp)
            bind(sh:value(?o) as ?oo)            
            bind(if (bound(?pp), sh:graph(?shape, ?pp), error())  as ?pathDetail)                                       
            bind(sh:graphbnode(?shape, ?foc) as ?focDetail)
            bind(if (bound(?oo), sh:graphbnode(?shape, ?oo), error())  as ?valueDetail)
            bind(sh:bnodeid() as ?bnode)
        } 
        values (?name ?sh ?cst ?shape ?foc  ?p ?o) { (UNDEF UNDEF UNDEF UNDEF UNDEF UNDEF UNDEF) }
        ) 
    {
        us:insert(g, validationReport);
        return(true)
    }
}

function sh:createMessage(shape, sh, cst) {
    if (isURI(cst) && cst = st:null, 
        xt:turtle(shape, sh),  
        xt:turtle(shape, cst))
}

function sh:getMessage(shape, sh, cst) {
    if (isURI(cst) && cst = st:null, 
        xt:value(shape, sh, sh:message),  
        coalesce(xt:value(shape, cst, sh:message), xt:value(shape, sh, sh:message)))
}


function sh:tracefinish() {
    xt:print(xt:turtle(validationReport))
}

# when suc = false, declare error on node (for future pprint)
function sh:visit(name, node, suc) {
    st:visit(name, node, suc)
}

# within graph shape {}
function dt:uri sh:severity(sh) {
    coalesce(xt:value(sh, sh:severity), sh:Violation)
}

function sh:message(sh){
    xt:value(sh, sh:message)
}

function sh:bnodeid(){
    coalesce(bnodeid, set(bnodeid = bnode()))
}


# trick datatype for st:turtle transformation to pprint a graph in Turtle format
function sh:graph(shape, var){
if (isBlank(var), 
    return(strdt(xt:turtle(shape, var), xt:graph)), 
    var)
}

function sh:graphbnode(shape, var){
    if (isBlank(var),  
        return(sh:graph(shape, var)),
        return(error()))
}


function sh:init(){
    map (sh:define, sh:def())
}

function sh:define(def){
    let ((name, value) = def){
        sh:setConstraint(sh:def, name, value)
    } ;
    return(true)
}

function dt:list sh:def(){
    let (list = @(
        (sh:function        sh:FunctionConstraintComponent)
        (sh:functioncst     sh:FunctionConstraintComponent)
        (sh:class           sh:ClassConstraintComponent)
        (sh:datatype        sh:DatatypeConstraintComponent)
        (sh:nodeKind        sh:NodeKindConstraintComponent)
        (sh:minCount        sh:MinCountConstraintComponent)
        (sh:maxCount        sh:MaxCountConstraintComponent)
        
        (sh:minExclusive	sh:MinExclusiveConstraintComponent)
        (sh:minInclusive	sh:MinInclusiveConstraintComponent)
        (sh:maxExclusive    sh:MaxExclusiveConstraintComponent)
        (sh:maxInclusive    sh:MaxInclusiveConstraintComponent)
        (sh:minLength       sh:MinLengthConstraintComponent)
        (sh:maxLength       sh:MaxLengthConstraintComponent)
        (sh:pattern	        sh:PatternConstraintComponent)
        (sh:languageIn      sh:LanguageInConstraintComponent)
        (sh:uniqueLang      sh:UniqueLangConstraintComponent)
        (sh:equals          sh:EqualsConstraintComponent)
        (sh:disjoint        sh:DisjointConstraintComponent)
        (sh:lessThan        sh:LessThanConstraintComponent)
        (sh:lessThanOrEquals sh:LessThanOrEqualsConstraintComponent)
        (sh:not             sh:NotConstraintComponent)
        (sh:and             sh:AndConstraintComponent)
        (sh:or              sh:OrConstraintComponent)
        (sh:xone            sh:XoneConstraintComponent)
        (sh:node            sh:NodeConstraintComponent)
        (sh:qualifiedValueShape sh:QualifiedValueShapeConstraintComponent)
        (sh:qualifiedMinCount   sh:QualifiedMinCountConstraintComponent)
        (sh:qualifiedMaxCount   sh:QualifiedMaxCountConstraintComponent)
        (sh:qualifiedValueShapeDisjoint sh:qualifiedValueShapeDisjointConstraintComponent)
        (sh:closed      sh:ClosedConstraintComponent)
        (sh:hasValue    sh:HasValueConstraintComponent)
        (sh:in          sh:InConstraintComponent)
        
        (sh:sparql      sh:SPARQLConstraintComponent)
    ) ) {
        return(?list)
    } 
} 



function sh:isdefby(name){
    sh:checkinit() ;
    let (amap = sh:getmap(sh:def)) {
        return (sh:getConstraint(sh:def, name))
    }
}

function sh:checkinit() {
    if (bound(mapmap), true, sh:start(xt:graph()))
}


