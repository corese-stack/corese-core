#
# Data Shape Property Path Interpreter
# PP expressions are searched in graph ?shape 
#
# Olivier Corby - Wimmics Inria I3S - 2016-2019
#

prefix sh:   <http://www.w3.org/ns/shacl#> 
prefix xsh:  <http://www.w3.org/ns/shacl#> 


# PPath interpreter Extension 


# extended path for triple
# [xsh:node xsh:subject] [xsh:triple xsh:predicate]
# exp = (oper param)
# oper = xsh:node|xsh:triple ; param = xt:subject|xt:predicate|xt:object
#
function dt:list sh:pathtriple(shape, subject, element, exp, inv, url) {
    let ((oper param) = exp) {
        funcall(sh:triplefun(oper), subject, element, param)
    }
}

function sh:triplefun(name) {
    if (name = xsh:triple, sh:triple, sh:mynode)
}

# element = triple | node
# param = xt:graph|xsh:subject|xsh:predicate|xsh:object
# when subject = s p o ; element = node ; param = xt:object
# -> xt:object(s p o) = node
#
function sh:mynode(subject, element, param) {
    #xt:print("subject:", subject, "element:", element, "param:", param);
    if (isExtension(element), # element : triple
        xt:list(funcall(param, element)),
    if (isExtension(subject), # element: node ; subject: s p o ;  -> compare node with s or o
        if (funcall(param, subject) = element, xt:list(element), xt:list()),
        # subject and element are nodes
    if (subject = element, xt:list(element), xt:list())))   
}

# element = node 
#
function sh:triple(subject, element, param) {
    if (param = xt:subject,   xt:edges(element, bnode()),
    if (param = xt:object,    xt:edges(bnode(), bnode(), element),
    if (param = xt:predicate, xt:edges(element),
    if (param = xt:graph,     sh:graphtriple(element), 
    xt:list()))))
}

# element = node 
#
function sh:graphtriple(element) {
    letdyn (name = element) {
        mapfindlist(lambda(atriple) { xt:graph(atriple) = name}, xt:edges())
    }
}

# function for [xsh:function [ us:foo(arg) ]] path element
# exp = (us:foo (arg))
# function name defined in operator, eg: xsh:exist, xsh:filter
#
function dt:list xsh:function(shape, subject, node, exp, inv, url) {
    let ((name param) = exp) {
        funcall(name, node, param)
    }
}






function sh:pattern(shape, node, arg) {
    regex(node, arg)
}


# ***********************************************


# sh:path (us:location [ xsh:ldpath (rdf:type) ])
# ?path = (rdf:type)
function dt:list xsh:ldpath(?shape, subject, ?s, ?path, ?inv, url) {
    let ((?p ?q) = ?path) {
    if (bound(?q), 
        return(sh:myldpath(?s, ?p, ?q)), 
        return(sh:myldpath(?s, ?p)))
    }
}

# dereference URI ?s and compute path ?p on graph URI
function dt:list sh:myldpath(?s, ?p){
    let (?g = xt:load(?s, st:nt, st:turtle)) {
        let (select ?g ?s ?p (aggregate(?o) as ?l) where  { graph ?g { ?s ?p ?o }}){
            if (us:trace(), xt:print("ldpath:", ?s, ?p, ?l), false);
            return(?l)
        }
    }
}

function dt:list sh:myldpath(?s, ?p, ?q){
    let (?g = xt:load(?s, st:nt, st:nt)) {
        let (select ?g ?s ?p ?q (aggregate(?o) as ?l) where  { graph ?g { ?s ?p [ ?q ?o ] }}){
        if (us:trace(), xt:print("ldpath:", ?s, ?p, ?q, ?l), false);
            return(?l)
        }
    }
}

function us:trace() {
    return (coalesce(traceService, set(traceService = false)))
}



# ***********************************************
# xsh:service (<uri> rdf:type)



#
# (ai:location [ <http://dbpedia.org/sparql> (rdf:type ) ] )
# arg = (<http://dbpedia.org/sparql> rdf:type )
#
# Path p and p/q are processed here. 
# Other path processed recursively by ppath interpreter with argument url = server URI
#
function dt:list xsh:service(shape, subject, node, arg, inv, url) {
    #if (us:trace(), xt:print("service1:", node, arg), false);
    if (isBlank(node)) { return (xt:list()) } ;
    let ((server | path) = arg,
         (pp qq)  = path) {
         if (us:trace()) { xt:print("service:", server, node, path) };
         let (list = 
                if (xt:size(path) = 2 && isURI(pp) && isURI(qq), 
                    sh:myservice(server, node, pp, qq), 
                if (xt:size(path) = 1 && isURI(pp), 
                    sh:myservice(server, node, pp),
                sh:evalpath(shape, subject, node, xt:list(sh:sequence, path), inv, server)))) 
            {
            if (us:trace()) {xt:print("service list:", list) } ;
            return (list)
        }
    }
}

# Simple path p
function dt:list sh:myservice(?uri, ?s, ?p) {
    let (select * (aggregate(?o) as ?l) where { service ?uri { ?s ?p ?o } }) {
        return (?l)
    }
}

# Simple path p/q
function dt:list sh:myservice(?uri, ?s, ?p, ?q) {
    #if (us:trace(), xt:print("service2:", ?p, ?q), false);
    let (select * (aggregate(?o) as ?l) where { service ?uri { ?s ?p [ ?q ?o ] } }) {
        return (?l)
    }
}


# (ai:location [ <http://dbpedia.org/sparql> (rdf:type ) ] )
# ?arg = (<http://dbpedia.org/sparql> rdf:type )
#
function dt:list xsh:service2(shape, subject, node, arg, inv, url) {
    #if (us:trace(), xt:print("service1:", node, ?arg), false);
    
    let ((server | path) = arg) {
        xt:print("service:", node, server, arg); 
        return(sh:evalpath(shape, subject, node, xt:list(sh:sequence, path), inv, server))
    }
}



