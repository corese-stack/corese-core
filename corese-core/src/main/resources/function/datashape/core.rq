#
# SHACL Interpreter 
#
# Olivier Corby - Wimmics Inria I3S - 2016-2019
#

prefix sh:  <http://www.w3.org/ns/shacl#> 
prefix msh: <http://ns.inria.fr/shacl/>


function sh:core(sh, vis, nodeList) {
    sh:core(sh, vis, nodeList, false)
}

#
# main function
# shape: shacl graph
# sh: current shape
# vis: true if report is needed
# nodeList:  list of target nodes of shape sh
# present=true: fail if path is empty (when there is a path)
#
function sh:core(sh, vis, nodeList, present) {
    let (b1 = sh:pathcore(sh, vis, nodeList, present),
         b2 = sh:booleancore(sh, vis, nodeList),
         b3 = sh:constraintcore(sh, vis, nodeList),
         b4 = sh:closedcore(sh, vis, nodeList)         
         ) {
        return (b1 && b2 && b3 && b4)
    }
}

# user api
function sh:eval(shape, node) {
    sh:core(shape, false, dt:list(node))
}

function sh:closedcore(sh, vis, nodeList) {
    let (res = true) {
        if (sh:isClosed(sh)) {
            let (anypred = bnode(), predList = sh:getPredicates(sh)) {
                #xt:print("closed:", predList, nodeList);
                if (sh:trace(), xt:print("core closed:", sh, nodeList), true); 
                for (node in dt:list(nodeList)) {
                    for ((s p o) in xt:edges(node, anypred)) {
                        let (suc = xt:member(p, predList)) {
                            if (suc, true, set(res = false));
                            sh:report(sh:closed, sh, s, p, o, suc, vis)
                        }
                    }
                }
            }
        } ;
        return (res)
    } 
}
 

function sh:pathcore(sh, vis, nodeList, present) {
    let (res = true) {
        for ((cst path) in sh:getShapeConstraint(sh:pathcore, sh)) {
            if (sh:trace(), xt:print("core path:", sh, nodeList), true); 
            let (suc = coalesce(sh:path(cst, vis, nodeList, path, present), false)) {
                if (suc, true, set(res = false))
            }
        } ;
        return (res)
    }
}


function sh:booleancore(sh, vis, nodeList) {
    let (res = true) {
        for ((bool cst) in sh:getShapeConstraint(sh:booleancore,  sh)) {
            if (sh:trace(), xt:print("core boolean:", sh, nodeList), true); 
            let (suc = coalesce(funcall(msh:fun(bool), bool, sh, cst, vis, nodeList), false)) {
                if (suc, true, set(res = false))
            }
        } ;
        return (res)
    }
}

function sh:constraintcore(sh, vis, nodeList) {
    let (cst = sh:getShapeConstraint(sh:constraintcore, sh)) {
        if (cst) {
            if (sh:trace(), xt:print("core constraint:", sh, nodeList), true); 
            let (suc = sh:constraint(sh, vis, nodeList)) {
                return (suc)
            }
        }
        else {
            return (true)
        }
    }
}




#
# record relevant properties of sh  in a map
#
function sh:getShapeConstraint(name, sh) {
    return (if (sh:hasConstraint(name, sh), 
        sh:getConstraint(name, sh), 
        sh:setConstraint(name, sh, funcall(name, sh:shaclGraph(), sh))))
}

function sh:getConstraint(name, shape, sh) {
    sh:getShapeConstraint(name,  sh)
}

function sh:isClosed(sh) {
    sh:getShapeConstraint(sh:isclosedcore, sh)
}

function sh:getPredicates(sh) {
    sh:getShapeConstraint(sh:closedcore, sh)
}

function sh:isclosedcore(shape, sh) {
    let (suc = exists { graph ?shape { ?sh sh:closed true } } ) {
        return (suc)
    }
}

function sh:closedcore(shape, sh) {
    let (select * (aggregate(distinct ?p) as ?list)
         where {
            graph ?shape {    
                ?sh sh:closed true                 
                { ?sh sh:property [ sh:path ?p ] filter isURI(?p) }
                union
                { ?sh sh:ignoredProperties/rdf:rest*/rdf:first ?p }
            }
         } ) {
         return (list)
    }
}

function sh:constraintcore(shape, sh) {
    let (suc = exists { graph ?shape { values ?sh { UNDEF } filter not exists { ?sh sh:path ?ppp } } } ) {
        return (suc)
    }
}



function sh:pathcore(shape, sh) {
    let (select * (aggregate(xt:list(coalesce(?cst, ?sh), ?p)) as ?list) 
        where {
            graph ?shape {  
                {?sh sh:property ?cst . ?cst sh:path ?p 
                filter not exists { ?cst sh:deactivated true } }
                union
                {?sh sh:path ?p  filter not exists { ?sh sh:deactivated true}}
            } } ) {
        return (list)
    }
}


function sh:booleancore(shape, sh) {
    sh:getGenericShape(shape, sh, sh:getShape(sh:boolean))
}




function msh:fun(name) {
    if (name = sh:not, msh:not, msh:boolean)
}


function msh:not (oper, sh, cst, vis, ls) {
        let (res = true) {
            for (s in dt:list(ls)) {
                let (suc = coalesce(! sh:core(cst, false, s), false)) {
                    if (suc, true, set(res = false));
                    sh:report(sh:not, sh, s, st:null, s,  suc, vis)
                }
            };
            return (res)
        }
}


# oper = sh:and | sh:or | sh:xone
function msh:boolean (oper, sh, cst, vis, ls) {
    let (res = true) {
        for (s in dt:list(ls)) {
            let (suc = coalesce(funcall(oper, sh:getShapeConstraint(sh:coreboolean, cst), s), false)) {
                sh:report(oper, sh, s, st:null, s, suc, vis);
                if (suc, true, set (res = false))
            }
        } ;
        return(res)
    }
}


# count fail
function xsd:boolean sh:and(cst, s){
    (sh:bool(cst, s, 0, 1) = 0)
}

# count success
function xsd:boolean sh:or(cst, s){
    (sh:bool(cst, s, 1, 0) > 0)
}

# count success
function xsd:boolean sh:xone(cst, s){
    (sh:bool(cst, s, 1, 0) = 1)
}

function xsd:integer sh:bool(cst, s, xsd:integer suc, xsd:integer fail){
   let (cc = 0, nodeList = xt:list(s)) {
        for (sh in cst) {
            let (res = sh:core(sh, false, nodeList)) 
            {
                 set (cc = cc +  if (res, suc, fail))  
            }
        } ;
        return (cc)
    }
}


function sh:coreboolean(shape, cst) {
     let ( 
        SELECT ?cst  ?shape (aggregate(?sh) as ?list)
		WHERE {
            graph ?shape { 
                ?cst rdf:rest*/rdf:first ?sh
            } } ) {  
            return (list)
        }
}















