<?xml version='1.0' encoding='UTF-8'?>
<!--
SPARQL Template Transformation
Olivier Corby - Wimmics - Inria UNS CNRS I3S
Fri Jun 21 13:43:42 CEST 2019
-->
<rdf:RDF  xmlns:rdf='http://www.w3.org/1999/02/22-rdf-syntax-ns#'
  xmlns='http://ns.inria.fr/sparql-template/'>
<rule>
<body>
<![CDATA[
template st:map(?jsonlist) {
   st:call-template-with(st:navlab, st:maplist, ?list)
}
where {
   bind (us:location(?jsonlist) as ?list)
}

]]>
</body>
</rule>

<rule>
<body>
<![CDATA[
template st:start {
   "<h2>Server Log</h2>"
   
   st:call-template(st:map,   ?jsonlist)
   st:call-template(st:chart, ?jsonlist, "country")
   #st:call-template(st:chart, ?jsonlist, "org")
}
where {
    # list of json descriptions of IP address
    bind (us:jsonlist2() as ?jsonlist)
}

]]>
</body>
</rule>

<rule>
<body>
<![CDATA[
#
# table: key->value
# generate a JSON SPARQL Result format for graphic chart 
#
template st:json(?table) {
format {

"""{
"head": { "vars": [ "x", "c"] },
"results": { "bindings": [
%s
]
}
}
"""

group {
    format {
        """{
        "x": { "type": "literal", "value": "%s"},
        "c": { "type": "typed-literal", "datatype": "http://www.w3.org/2001/XMLSchema#integer", "value": "%s"}
        }"""
        ?key ?value
    }
    ; separator=',\n'
}

}


}
where {    
    select * where {
        values ?table { UNDEF }
        values (?key ?value)    { unnest(?table) }
    }
    order by desc(?value) ?key
}
]]>
</body>
</rule>

<rule>
<body>
<![CDATA[
prefix d3: <http://ns.inria.fr/sparql-template/format/d3/>
template st:chart(?jsonlist, ?key) {
    format {
        d3:frameselect.html
        ?id
        coalesce(?json, "{ error: 'error when reading st:mappings'}")
    }
}
where {
    bind (substr(replace(rand(), "\\.", ""), 0, 5) as ?id)
    bind (us:nbmap(?jsonlist, ?key) as ?table) 
    bind (st:call-template(st:json, ?table) as ?json)
}
]]>
</body>
</rule>

<rule>
<body>
<![CDATA[
template st:profile {
}
where {
}

# generate a list of json description of IP address
function us:jsonlist() {
    let (?map = ds:getPublicDatatypeValue(true),
         #?host = xt:get(?map, st:host),
         ?host = us:map(),
         ?iplist   = us:iplist(?host),
         ?jsonlist = maplist(us:describe, ?iplist)) {
        return(?jsonlist)
    }
}

function us:jsonlist2() {
    let (?iplist   = us:hostlist(),
         ?jsonlist = maplist(us:describe, ?iplist)) {
        return(?jsonlist)
    }
}

function us:hostlist() {
    let (select (aggregate(?key) as ?list) 
         where { 
          service <http://corese.inria.fr/sparql> {
            bind (ds:getPublicDatatypeValue(true) as ?map)
            bind (xt:get(?map, st:host) as ?host)
            values (?key ?value) { unnest(?host) }
         }}) {
    ?list
    }
}


# list of location of IP address
function us:location(?jsonlist) {
    maplist(us:locate, ?jsonlist)
}

# map(ip->nb)
# generate a list of IP address
function us:iplist(?map) {
    maplist(lambda((?key, ?value)) { ?key }, ?map)
}

# extract location from json description of IP address
function us:locate(?json) {
    let (?ip   = xt:get(?json, "ip"),
         ?pair = xt:get(?json, "loc"),
         ?lat  = strbefore(?pair, ","),
         ?lon  = strafter(?pair,  ",")) {
         xt:list(?ip, xsd:decimal(?lat), xsd:decimal(?lon))
    }
}

# call a service to get a json description of IP address
function us:describe(?ip) {
 let (?res  = xt:read(concat("https://ipinfo.io/", ?ip)),
      ?json = xt:json(?res)) {
      xt:print(?json, "\n") ;
      return(?json)
    }
}

# ?jsonlist: list of json description of IP address
# generate a map(slotvalue->nb)
function us:nbmap(?jsonlist, ?key) {
    let (?map = xt:map()) {
        for (?json in ?jsonlist) {
            let (?c = xt:get(?json, ?key)) {
                xt:set(?map, ?c, coalesce(1 + xt:get(?map, ?c), 1))
            }
        } ;
        #xt:set(?map, "total", xt:size(?jsonlist)) ;
        return (?map)
    }
}















function us:map() {
    let (?map = xt:map()) {
    map(lambda(?ip, ?map) { xt:set(?map, ?ip, 1) }, 
    xt:list(), xt:list(?map) );
        return (?map)
    }
}

function us:json(?json, ?key) {
    let (?str  = strafter(?json, concat("\"", ?key, "\": \"")),
         ?pair = strbefore(?str, "\"")) {
         return(?pair)
    }
}

]]>
</body>
</rule>

</rdf:RDF>
