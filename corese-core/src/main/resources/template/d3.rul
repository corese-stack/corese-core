<?xml version='1.0' encoding='UTF-8'?>
<!--
SPARQL Template Transformation
Olivier Corby - Wimmics - Inria UNS CNRS I3S
Mon Jan 28 11:37:38 CET 2019
-->
<rdf:RDF  xmlns:rdf='http://www.w3.org/1999/02/22-rdf-syntax-ns#'
  xmlns='http://ns.inria.fr/sparql-template/'>
<rule>
<body>
<![CDATA[
template st:map {
    st:call-template-with(st:navlab, st:map, ?list)        
} 
where {
    bind (st:get(st:pos) as ?list)
    filter (bound(?list) && xt:size(?list) > 0)
}
]]>
</body>
</rule>

<rule>
<body>
<![CDATA[
template st:graph {
  st:call-template(st:nodes)
  ","
  st:call-template(st:edges)
} 
where {
    bind (xt:print('graph size', xt:size(xt:graph())) as ?tmp)
}
]]>
</body>
</rule>

<rule>
<body>
<![CDATA[
prefix ft: <http://ns.inria.fr/sparql-template/format/d3/>
template st:start {
  format {
      ft:graph.html
      st:call-template(st:graph)
  }
} 
where {
}
]]>
</body>
</rule>

<rule>
<body>
<![CDATA[
prefix ft: <http://ns.inria.fr/sparql-template/format/d3/>
template st:frame(?pretty) {
  format {
      ft:frame.html
      ?id
      us:plist(?list)
      st:call-template(st:graph)
  }
} 
where {
    bind (if (bound(?pretty), us:declare(?pretty), true) as ?tmp)
    bind (substr(replace(rand(), "\\.", ""), 0, 5) as ?id)
    bind (coalesce(st:get(st:hierarchy), xt:list(rdfs:subClassOf)) as ?list)
}

]]>
</body>
</rule>

<rule>
<body>
<![CDATA[
template st:nodes {
  "\"nodes\":[\n"
  group {
    format {
        '{"id": "%s", "label": "%s", "group": "%s"}'
        
        us:get(?s) us:label(?s) us:kind(?s)
        }
    ; separator = ",\n"
  }
  "\n]\n"
} 
where {
  bind (us:start() as ?start)
  
  {select distinct ?s where {
    { ?s ?p ?o } union { ?o ?p ?s }
  } 
  order by ?s
  }
  
  bind (us:record(?s) as ?tmp)
}
]]>
</body>
</rule>

<rule>
<body>
<![CDATA[
template st:profile {}
where {}

function us:start() {
    set(?map = xt:map())
}

function us:kind(?s) {
    if (st:cget(st:group, ?s, st:other), 2,
    if (isURI(?s), 1, 
    if (isBlank(?s), 2, 3)))
}

function us:record(?s) {
   xt:set(?map, ?s, coalesce(xt:get(?map, ?s), concat('n', kg:number())))
}

function us:get(?s) {
    xt:get(?map, ?s)
}

function us:declare(?fun) {
    set(?pretty = ?fun)
}

function us:label(?s) {
    if (bound(?pretty), us:pretty(funcall(?pretty, ?s)), us:pretty(?s))
}

function us:pretty(?s) {
    if (isBlank(?s), "",
    if (isLiteral(?s), us:literal(?s), us:uri(?s)))
}

function us:uri(?u) {
    if (st:get(st:mode, st:literal), "", 
    if (contains(?u, ".jpg"), us:shorten(st:turtle(?u, true)), st:turtle(?u, true)))
}

function us:shorten(?l) {
    let (?s = if (strlen(?l) > 50, concat(substr(?l, 1, 50), "..."), ?l)) { ?s }
}

function us:literal(?l) {
    if (st:get(st:mode, st:uri), "", 
    let (?s = us:shorten(?l)) {
        replace(replace(str(?s), "\n", ""), "\"", "'")
    }
    )
}

function us:plist(?list) {
    reduce(lambda(?a, ?b) {concat(?a, ", " , ?b) }, 
        maplist(lambda(?name) { st:format("\"%s\":true", st:turtle(?name)) }, ?list)
    )
}

]]>
</body>
</rule>

<rule>
<body>
<![CDATA[
template st:edges {
  "\"edges\":[\n"
  
  group { 
  
    format {
        '{"source": "%s", "target": "%s", "label": "%s", "id": "e%s" }'
        us:get(?s) us:get(?o) us:label(?p) kg:number()
    }
    
    ; separator = ",\n"
  }
  
  "\n]\n"
} 
where {
  select * where {
    ?s ?p ?o 
  }
  order by ?s ?o ?p
}
]]>
</body>
</rule>

</rdf:RDF>
