<?xml version='1.0' encoding='UTF-8'?>
<!--
SPARQL Template Transformation
Olivier Corby - Wimmics - Inria UNS CNRS I3S
Mon Oct 14 13:34:52 CEST 2019
-->
<rdf:RDF  xmlns:rdf='http://www.w3.org/1999/02/22-rdf-syntax-ns#'
  xmlns='http://ns.inria.fr/sparql-template/'>
<rule>
<body>
<![CDATA[
#
# SHACL Interpreter
# http://w3c.github.io/data-shapes/shacl/
# Functions are defined in resources/function/datashape, see target.rq and main.rq
#
# main: shapes with targets
# core: shape constraints (property, path, constraint, and, or, not, closed)
# path:       property path constraint
# constraint: node constraint
#
# Olivier Corby - Wimmics Inria I3S - 2016-2019
#
prefix sh: <http://www.w3.org/ns/shacl#> 

template st:start(?shapeGraph) {
    ?suc
}
where {
  bind (sh:starter() as ?st)
  bind (coalesce(?shapeGraph, st:get(st:shape), st:shape) as ?shape)
  bind (xt:focus(?shape, sh:sibling()) as ?sib)
  bind (sh:target(?shape) as ?suc) 
  bind (sh:success(?suc)  as ?b)
}
]]>
</body>
</rule>

<rule>
<body>
<![CDATA[
#
# Store sibling shapes of qualified shapes
# @deprecated
#
template sh:sibling(?shape) {   
    if (bound(?qsh), st:cset(sh:sibling, ?qsh, ?list), true)
}
where {
    graph ?shape {
        select ?qsh (aggregate(xt:list(?sibling, ?path)) as ?list) 
        where {
            select distinct ?qsh ?sibling ?path
            where {
                ?root sh:property [ sh:qualifiedValueShape ?qsh ];
                      sh:property [ sh:qualifiedValueShape ?sibling ; sh:path ?path ]  
                filter (?sibling != ?qsh)
            }
        }
        group by ?qsh
    }
}
]]>
</body>
</rule>

<rule>
<body>
<![CDATA[
#
# Data Shape Validator
# http://w3c.github.io/data-shapes/shacl/
#
# main: shapes with targets
# core: shape constraints (property, path, constraint, and, or, not, closed)
# property:   property predicate constraint
# path:       property path constraint
# constraint: node constraint
#
# Olivier Corby - Inria I3S - 2016
#
prefix sh: <http://www.w3.org/ns/shacl#> 

template st:main(?shape, ?name, ?s, ?sh) {
    ?suc
}
where {
  bind (sh:starter() as ?st)
  #bind (coalesce(st:get(st:shape), st:shape) as ?shape)
  bind (xt:focus(?shape, sh:sibling()) as ?sib)
  bind (if (bound(?sh), funcall(?name, ?shape, ?s, ?sh), funcall(?name, ?shape, ?s)) as ?suc) 
  bind (sh:success(?suc) as ?b)
}
]]>
</body>
</rule>

<rule>
<body>
<![CDATA[
prefix sh:   <http://www.w3.org/ns/shacl#> 
prefix fun:  <http://www.w3.org/ns/shacl#> 
prefix java: <http://www.w3.org/ns/shacl#>  
prefix doc:  <http://w3c.github.io/data-shapes/shacl/#>

# @compile <fr.inria.corese.extension.DataShape>  @path </user/corby/home/NetBeansProjects/corese-github/kgtool/src/main/java/fr/inria/corese/extension/>

# @import <http://ns.inria.fr/sparql-template/function/datashape/main.rq>

@import <function/datashape/main.rq>  <function/datashape/target.rq>  

template st:profile {} where {}


@skip
function st:aggregate(out) {
  st:agg_and(out)
}

@skip
function st:default(term){
    true
}

@skip
function st:defaultNamed(term){
    true
}

#
# Template optimizer
# Results of graph ?shape { ?sh sh:property ?cst } are cached in table: ?sh -> Mappings
# Next evaluations are retrieved from cache: 40% faster
#
function st:optimize(shape, sh){
    true
}







]]>
</body>
</rule>

<rule>
<body>
<![CDATA[
#
# Select target nodes
# for each shape ?sh, aggregate target nodes in ?list
# call sh:hasShape for each shape ?sh with list of target nodes ?list
#
prefix sh: <http://www.w3.org/ns/shacl#> 

template (?shape) {
  ?suc
}
where {

  {
   select  ?s ?shape ?sh  (aggregate(distinct ?s) as ?list) 
   where { 
  
    {graph ?shape {
        ?sh sh:targetSubjectsOf ?p 				
        filter not exists { ?sh sh:deactivated true} }
        
     ?s ?p ?o}
    
    union
    
    {graph ?shape {
        ?sh sh:targetObjectsOf ?p 				
        filter not exists { ?sh sh:deactivated true} }
        
     ?x ?p ?s}
    
    union 
    
    {graph ?shape {
        ?sh sh:targetClass ?c 
        filter not exists { ?sh sh:deactivated true} }
        
     ?s rdf:type/rdfs:subClassOf* ?c}
     
     union 
    
    {graph ?shape {
        ?sh a sh:NodeShape, rdfs:Class
        filter not exists { ?sh sh:deactivated true} }
        
     ?s rdf:type/rdfs:subClassOf* ?sh} 
     
    union 
     
    {graph ?shape {
        ?sh sh:targetNode ?s
        filter not exists { ?sh sh:deactivated true} }
    }
                      
  } group by ?sh
  }
  #filter xt:display("target: ", ?list) 
  filter (xt:size(?list) > 0)
  bind (sh:hasShape(?shape, ?sh, true, ?list) as ?suc)

}


]]>
</body>
</rule>

</rdf:RDF>
